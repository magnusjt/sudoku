{"version":3,"sources":["core/utils/misc.ts","core/utils/sudokuUtils.ts","theme.ts","core/utils/effects.ts","core/solvers/basic.ts","core/solvers/singles.ts","core/solvers/pointer.ts","core/solvers/subset.ts","core/solvers/fish.ts","core/solvers/uniqueRectangle.ts","core/solvers/skyscraper.ts","core/solvers/emptyRectangle.ts","core/solvers/wing.ts","core/solvers/bruteForce.ts","core/solvers/chainGraph.ts","core/solvers/chains.ts","core/solvers/bug.ts","core/solvers/simpleColoring.ts","core/solve.ts","core/sudoku.ts","selectors.ts","gui/board.tsx","gui/solver.tsx","gui/puzzle-select.tsx","gui/digit-selector.tsx","gui/help.tsx","core/utils/hasUniqueSolution.ts","core/utils/generateName.ts","core/utils/getBoardMetaData.ts","gui/import-export.tsx","gui/hints.tsx","gui/app.tsx","state.ts","storage.ts","index.tsx"],"names":["getCombinations","items","len","initIndex","combos","i","length","rest","push","combo","isNotNull","x","first","iterable","Symbol","iterator","next","value","allResults","Array","from","filter","unique","arr","Set","uniqueBy","isEqual","result","forEach","a","some","b","difference","arr1","arr2","intersectionOfAll","flat","every","subArr","arraysEqual","groupBy","by","reduce","groups","item","key","memoize","fn","getKey","memo","hasOwnProperty","pointsEqual","pointA","pointB","id","allCandidates","fill","map","_","candidatesExcept","cands","getPointId","y","getAllPoints","points","getAllUnfilledPoints","board","p","getBoardCell","getColumn","col","getRow","row","getBox","point","box","xStart","Math","floor","yStart","getAllRows","rows","getAllCols","cols","getBoxX","boxNumber","getBoxY","getAllBoxes","boxes","k","getAllHouses","getBoxGroups","line","slice","getAllHousesMinusFilledPoints","getAffectedPoints","getRowsOutsideBox","boxY","getColsOutsideBox","boxX","getAffectedPointsInCommon","getRowNumber","getColNumber","getBoxNumber","isBoardFinished","cloneBoard","cell","candidates","pointsWhere","getPointsWithCandidates","cand","includes","getPointsWithNCandidates","n","canPutDigit","digit","boardHasError","solution","boardIsComplete","theme","createMuiTheme","palette","type","primary","main","secondary","text","typography","button","textTransform","textColor","backgroundColor","background","paper","backgroundDisabledColor","lighten","borderHardColor","darken","boardBackgroundColor","selectedColor","affectedColor","highlightedColor","highlightedCandidateColor","setCandidateColor","eliminateCandidateColor","actorCandidateColor","actorChainCandidateYesColor","getContrastText","effectsEqual","eff1","eff2","number","numbers","groupId","uniqueEffects","effects","removeCandidatesFromPoints","candidatesToRemove","removeCandidates","eff","addCandidatesToPoints","candidatesToAdd","addCandidates","removeCandidateFromPoints","removeCandidateFromAffectedPoints","toggleCandidate","applyEffects","effect","c","basicEliminationsGenerator","actors","f","basicElimination","fullHouseGenerator","nakedSingleGenerator","hiddenSingleGenerator","pointsWithCand","fullHouse","nakedSingle","hiddenSingle","pointerGenerator","inversePointerGenerator","pointsToRemove","pointer","inversePointer","nakedSubsetGenerator","subsetGenerator","pointsInside","pointsOutside","flatMap","subsetPointLists","nakedPair","hiddenPair","nakedTriple","hiddenTriple","nakedQuad","hiddenQuad","fishGenerator","finnedFishGenerator","getFishResult","fishPoints","getLineNumber","getLine","lines","Object","values","pointsOnLines","minInstancesPerHouse","allPoints","rowsWithLen","colsWithLen","allowSashimi","fishPointsIncludingFins","possibleLines","fins","fishLinePoints","pointsToRemoveIfRegularFish","pointsToRemoveIfFin","possibleRows","possibleCols","xWing","swordfish","jellyfish","xWingFinned","xWingFinnedSashimi","swordfishFinned","swordfishFinnedSashimi","jellyfishFinned","jellyfishFinnedSashimi","findNakedPairs","pairs","pointsWith2Cands","j","uniqueRectangle1","pair","matchingPairs","colPair","corners","xs","ys","missingCorner","hiddenRectangle","unfilledPoints","biValuePoints","startingCorner","rowCorner","colCorner","oppositeCorner","oppositeCell","hiddenRect","affected","hp","skyscraperGenerator","getSkyscraperResult","skyscraperPoints","pointsOnLine","pointsToCheck","affectedInCommon","rowsWithTwo","colsWithTwo","skyscraper","emptyRectangleGenerator","getResult","pairHouse","erPoints","pointerX","pointerY","pointToRemove","otherPoint","find","pairHouses","colNumbers","pointerLines","colNumber","wholeColumn","restPoints","emptyRectangle","xyWingGenerator","xyzWingGenerator","wWingGenerator","pivot","affectedBiValuesPoints","xy","zValues","z","pincer1","pincer2","triValuePoints","pivotCands","candidatesEqual","cands1","cands2","house","pointsWithX","affected1","affected2","w","wx","wxPoints1","wxPoints2","common","xyWing","xyzWing","wWing","generateBruteForceDigits","clonedBoard","solve","bruteForce","getPointKey","getGroupId","group","join","getLinks","node","effectsIfTrue","effectsIfFalse","groupEffectsIfTrue","groupEffectsIfFalse","prev","getNakedSingle","getHiddenSingles","getSingleFalseSingleEffects","getSingleFalseGroupEffects","getGroupFalseGroupEffects","getSingleTrueSingleEffects","getSingleTrueGroupEffects","allGroups","singleTrueSingleEffects","getGroupTrueGroupEffects","getGroupFalseSingleEffects","falseGroup","isColumn","isRow","housesToCheck","trueGroup","sameBox","sameCol","sameRow","getGroupTrueSingleEffects","groupTrueSingleEffects","groupEffects","createTable","withGroups","sort","groupsTable","createGroupTable","table","link","links","getAllLinks","getNodePoints","linkIsInternalWithinPoint","getSeenKeys","iterateChainsInTable","keepLink","check","maxDepth","isValidNextLink","chain","seen","last","requiredLinkType","lastWasInternal","nextIsInternal","has","queue","queueItem","firstLink","lastLink","isLoop","nextLinks","nextLink","chainToActors","chainSet","chainIsAlternatingInternal","remotePairChain","start","end","xChain","xyChain","getDiscontinuousNiceLoop","getContinuousNiceLoop","pointsInChain","weakSingleLinks","prevPoints","nextPoints","prevBoxes","nextBoxes","prevCols","nextCols","prevRows","nextRows","getAicType1","getAicType2","point1","point2","isGrouped","aicType1","findChain","aicType2","aicType1Grouped","aicType2Grouped","discontinuousNiceLoop","discontinuousNiceLoopGrouped","continuousNiceLoop","continuousNiceLoopGrouped","bugPlus1Generator","hasBug","occurrences","unfilled","triValuePoint","triValueCell","extraCand","bug","bugPlus1","simpleColoringGenerator","oppositeColor","color","getNextQueueItems","pointKey","colorFromPoint","startingPoint","startingKey","colors","shift","candsWithPoints","checked","add","uncoloredPoints","uncoloredPoint","simpleColoring","techniques","difficulty","createTechniqueRunners","allowStopEarly","results","addResult","name","grouped","depth","shouldStopEarly","initialized","init","actorsDiff","effectsDiff","createFindChain","basic","difficulties","t","difficultyLevels","beginner","easy","medium","hard","expert","artisan","master","jedi","getSolution","applyTechniques","techniqueTypes","moreToGo","techType","techniqueRunners","tech","Error","res","applyBasicEliminations","allBasicEliminations","iterate","technique","runTechnique","boardFromStr","input","given","boardFromInput","matchAll","split","Number","applyInputValue","mode","toggleValue","prepareBoardForSolver","resetCandidates","selectSolution","createSelector","state","game","initialBoard","selectHasError","selectIsComplete","selectHints","hasError","getTechniquesUntilNextValue","selectPuzzles","puzzles","selectUserData","userData","Candidates","props","fontSize","height","style","display","gridTemplateColumns","gridTemplateRows","gap","width","fontFamily","bgs","justifyContent","alignItems","getCellBackgroundColor","selected","highlightedNumber","selectedDigit","hasElimination","cellHasElimination","hasSetValue","cellHasSetValue","hasActor","actor","cellHasActor","bg","CellDisplay","solveResult","celebration","React","useState","celebrationCounter","setCelebrationCount","useEffect","setTimeout","useMemo","candBgs","getCandidateBackgrounds","pointNumber","seed","round","border","borderColor","lineHeight","addHardBorder","side","cellHeight","BoardDisplay","isSelecting","setIsSelecting","ref","useRef","setHeight","setHeightAndRequest","current","clientWidth","clientHeight","currentWidth","currentHeight","min","setBoardHeightDom","window","requestAnimationFrame","solutionBoard","useSelector","selectedCells","affectedPoints","addSelect","actions","addSelectedCell","endSelect","useCallback","useEventListener","position","zIndex","data-x","data-y","className","onMouseDown","e","ctrlKey","setSelectedCells","startSelect","onMouseOver","onMouseUp","onTouchStart","startSelectTouch","onTouchMove","loc","touches","target","document","elementFromPoint","clientX","clientY","actualTarget","closest","xStr","getAttribute","yStr","onTouchCancel","onTouchEnd","pointToStr","Solver","onSolveResult","skippedTechniques","setSkippedTechniques","isMobile","useMediaQuery","mobileMediaQuery","onToggleTechnique","s","boardBeforeSolve","Button","variant","fullWidth","onClick","onPlayFromHere","flexDirection","skipped","size","PuzzleSelect","puzzleData","selectedTab","setSelectedTab","showTechniques","setShowTechniques","custom","Date","date","meta","puzzle","maxNumberOfTechniques","max","Table","TableHead","TableRow","TableCell","align","TableBody","solved","boardData","hasProgress","progress","hover","Typography","LinearProgress","onPuzzleSelect","mobileTable","Paper","padding","marginBottom","marginLeft","marginRight","marginTop","overflowX","disabled","Divider","flex","minHeight","overflowY","DigitCircle","bgColor","finished","font","cursor","outline","borderRadius","margin","DigitSelector","finishedDigits","digits","entries","d","getFinishedDigits","flexWrap","paddingRight","onClickDigit","techniqueDescriptions","uniqueRectangle","Help","href","rel","Accordion","AccordionSummary","AccordionDetails","trim","getSolutionCount","count","adjectives","subject","rand","random","generateName","getBoardMetaData","getTechniquesRequiredForSolvingBoard","reverse","level","getOverallDifficulty","givens","String","mergeUserData","oldData","newData","ImportExport","importState","setImportState","importBoardStr","setImportBoardStr","boardStrValidation","setBoardStrValidation","onImport","str","obj","JSON","parse","isArray","looksLikeUserData","newUserData","setUserData","err","onImportBoardStr","hasUniqueSolution","toISOString","onExport","time","format","fileName","fileType","blob","Blob","createElement","download","URL","createObjectURL","dataset","downloadurl","body","appendChild","click","removeChild","revokeObjectURL","downloadJsonStr","stringify","onDrop","acceptedFiles","file","reader","FileReader","onload","readAsText","useDropzone","maxFiles","getRootProps","getInputProps","TextField","onChange","placeholder","Hints","hints","dummyBoard","App","hintsOpen","setHintsOpen","puzzleSelectOpen","setPuzzleSelectOpen","importExportOpen","setImportExportOpen","helpOpen","setHelpOpen","inputMode","solverState","solver","boardStack","boardMetaData","isComplete","toggleSolver","toggleHints","onSetDigit","setDigit","onSelectDigit","selectDigit","clearSelected","onGlobalKeyDown","toLowerCase","setInputMode","undo","test","parseInt","maxWidth","paddingLeft","paddingBottom","undefined","right","opacity","setSolveResult","playFromSolver","Dialog","open","onClose","fromProgress","startPuzzle","initialState","deserialize","data","localStorageSet","localStorage","setItem","storage","store","middleware","applyMiddleware","prevUserData","getState","action","currUserData","createStorageMiddleware","enhancer","composeWithDevTools","createStore","dispatch","setState","setPuzzles","startGame","metaData","originalBoard","boardStr","boardToStr","createActions","getItem","localStorageGet","fetch","process","then","ReactDOM","render","StrictMode","ThemeProvider","CssBaseline","getElementById"],"mappings":"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N,OACA,WACA,UACA,QACA,QACA,WACA,YAEJC,KAAM,CACF,OACA,eACA,YACA,OACA,WACA,UACA,aACA,QAEJC,OAAQ,CACJ,WACA,WACA,cACA,QACA,UACA,YACA,SACA,UAEJC,KAAM,CACF,OACA,SACA,SACA,YACA,aACA,SACA,WACA,WAEJC,OAAQ,CACJ,QACA,UACA,UACA,cACA,WACA,aACA,aACA,aACA,WAEJC,QAAS,CACL,YACA,aACA,YACA,UACA,aACA,WACA,aACA,YAEJC,OAAQ,CACJ,OACA,QACA,YACA,UACA,eACA,aACA,UACA,WAEJC,KAAM,CACF,cACA,WACA,UACA,UACA,YACA,aACA,aAIFuO,GAAU,CACZ9O,SAAU,CACN,aACA,QACA,YACA,WACA,SACA,mBACA,QACA,OAEJC,KAAM,CACF,WACA,SACA,cACA,UACA,MACA,WACA,aACA,eAEJC,OAAQ,CACJ,YACA,QACA,YACA,eACA,YACA,UACA,gBACA,gBAEJC,KAAM,CACF,YACA,iBACA,cACA,WACA,UACA,SACA,UACA,OACA,YAEJC,OAAQ,CACJ,aACA,eACA,sBACA,UACA,YACA,aACA,YACA,UAEJC,QAAS,CACL,cACA,oBACA,UACA,iBACA,YACA,SACA,QACA,cAEJC,OAAQ,CACJ,WACA,QACA,UACA,aACA,UACA,YACA,YACA,YAEJC,KAAM,CACF,YACA,WACA,eACA,SACA,cACA,aACA,eAIFwO,GAAO,SAAChkB,GAAD,OAAepC,KAAKC,MAAOD,KAAKqmB,SAASjkB,IAEzCkkB,GAAe,SAACnQ,GACzB,MAAO,CACH+P,GAAW/P,GAAYiQ,GAAKF,GAAW/P,GAAY1a,SACnD0qB,GAAQhQ,GAAYiQ,GAAKD,GAAQhQ,GAAY1a,UAC/CiT,KAAK,MC3JE6X,GAAmB,SAAClnB,GAM7B,IAJA,IAAM6W,EVgN0C,SAAC7W,GAIjD,IAHA,IAAMmD,EAAWqV,GAAYxY,GAEvB6W,EAAuB,KAClB,CACP,IAAMmC,EAAMG,GAAQnZ,GACpB,GAAW,OAARgZ,EACC,MAAM,IAAID,MAAM,kCAEpB,GAAG7V,GAAclD,EAAOmD,GACpB,MAAM,IAAI4V,MAAM,mBAAqBlC,EAAWxH,KAAK,OAEzD,GAAqB,SAAlB2J,EAAII,UACH,MAEJpZ,EAAQgZ,EAAIhZ,MACZ6W,EAAWva,KAAK0c,EAAII,WAExB,OAAOhc,EAAOyZ,GUlOKsQ,CADnBnnB,EAAQga,GAAsBha,IAExB8W,EVkI0B,SAAC4B,GACjC,IAAM5B,EAAa,UAAID,IAAYuQ,UAAUza,MAAK,SAAAmL,GAAC,OAAIY,EAAe7V,SAASiV,EAAEtU,SAAQsT,WACzF,MAAO,CAACA,aAAYuQ,MAAOtP,GAAiBjB,IUpIzBwQ,CAAqBzQ,GACpC0Q,EAAS,EACT1D,EAAY,GACRjkB,EAAI,EAAGA,EAAI,EAAGA,IAClB,IAAI,IAAInD,EAAI,EAAGA,EAAI,EAAGA,IAAI,CACtB,IAAM+F,EAAOxC,EAAMJ,GAAGnD,GACtBonB,GAA4B,OAAfrhB,EAAKzF,MAAiB,IAAMyqB,OAAOhlB,EAAKzF,OAClDyF,EAAKgX,OACJ+N,IAIZ,MAAO,CACHpQ,KAAM8P,GAAanQ,EAAWA,YAC9BD,aACAC,aACAyQ,SACA1D,c,oBCDF4D,GAAgB,SAACC,EAAmBC,GAAgC,IAAD,IACrE,MAAO,CACH/D,OAAQxmB,EAAO,GAAD,6BAAMuqB,EAAQ/D,cAAd,QAAwB,IAAxB,YAAgC8D,EAAQ9D,UACtDG,SAAS,2BAAK2D,EAAQ3D,UAAa4D,EAAQ5D,UAC3ChB,OAAQxlB,EAAS,GAAD,6BAAMoqB,EAAQ5E,cAAd,QAAwB,IAAxB,YAAgC2E,EAAQ3E,UAAS,SAACplB,EAAGE,GAAJ,eAAU,UAAAF,EAAEulB,YAAF,eAAQW,cAAR,UAAsBhmB,EAAEqlB,YAAxB,aAAsB,EAAQW,gBAIpG+D,GAAe,SAAC3M,GACzB,IAAMF,EAAWiE,aAAYlE,IADyB,EAEhB+B,IAAMC,SAAwB,MAFd,mBAE/C+K,EAF+C,KAElCC,EAFkC,OAGVjL,IAAMC,SAAS,IAHL,mBAG/CiL,EAH+C,KAG/BC,EAH+B,OAIFnL,IAAMC,SAAwB,MAJ5B,mBAI/CmL,EAJ+C,KAI3BC,EAJ2B,KAMhDC,EAAWtL,IAAM0C,aAAY,SAAC6I,GAChC,IACI,IAAMC,EAAMC,KAAKC,MAAMH,GACvB,GAnCc,SAACC,GACvB,OAAOprB,MAAMurB,QAAQH,EAAIzE,SAAWyE,EAAItE,UAAY9mB,MAAMurB,QAAQH,EAAItF,QAkC1D0F,CAAkBJ,GAAM,CACxB,IAAMK,EAAcjB,GAAc1M,EAAUsN,GAG5C,OAFAjJ,GAAQuJ,YAAYD,QACpBZ,EAAe,uBAGtB,MAAMc,IAEPd,EAAe,mFAChB,CAAC/M,IAEE8N,EAAmBhM,IAAM0C,aAAY,WACvC,IAAM6I,EAAML,EAAerB,OAC3B,GAAmB,KAAf0B,EAAIhsB,OAAR,CAIA,IAAM4D,EAAQsZ,GAAa8O,GAC3B,GHnEyB,SAACpoB,GAG9B,OAFAA,EAAQuC,EAAWvC,GAEF,IADH2mB,GAAiB3mB,GGiEtB8oB,CAAkB9oB,GAAvB,CAIA,IAAMkjB,EAAOgE,GAAiBlnB,GACxB0oB,EAAcjB,GAAc1M,EAAU,CACxCgI,OAAQ,CAAC,CAAEG,OAAMD,MAAM,IAAID,MAAO+F,kBAEtC3J,GAAQuJ,YAAYD,GACpBR,EAAsB,2EARlBA,EAAsB,kCALtBA,EAAsB,sCAc3B,CAACH,EAAgBhN,IAEdiO,EAAWnM,IAAM0C,aAAY,WAC/B,IAAM0J,EAAOC,KAAO,IAAIlG,KAAQ,aA9DhB,SAACpf,EAAMulB,GAC3B,IAAMC,EAAW,mBACXC,EAAO,IAAIC,KAAK,CAAC1lB,GAAO,CAAEJ,KAAM4lB,IAChCzrB,EAAIgjB,SAAS4I,cAAc,KACjC5rB,EAAE6rB,SAAWL,EACbxrB,EAAE0oB,KAAOoD,IAAIC,gBAAgBL,GAC7B1rB,EAAEgsB,QAAQC,YAAc,CAACR,EAAUzrB,EAAE6rB,SAAU7rB,EAAE0oB,MAAMhX,KAAK,KAC5D1R,EAAEyd,MAAMC,QAAU,OAClBsF,SAASkJ,KAAKC,YAAYnsB,GAC1BA,EAAEosB,QACFpJ,SAASkJ,KAAKG,YAAYrsB,GAC1Buf,YAAW,kBAAMuM,IAAIQ,gBAAgBtsB,EAAE0oB,QAAO,MAoD1C6D,CAAgB5B,KAAK6B,UAAUpP,EAAU,KAAM,GAAhC,iBAA8CkO,EAA9C,YAChB,CAAClO,IAEEqP,EAASvN,IAAM0C,aAAY,SAAC8K,GAC9B,GAA6B,IAAzBA,EAAcjuB,OAAlB,CAGA,IAAMkuB,EAAOD,EAAc,GAErBE,EAAS,IAAIC,WACnBD,EAAOE,OAAS,kBAAMtC,EAASoC,EAAO9sB,SACtC8sB,EAAOG,WAAWJ,MACnB,CAACnC,IArDkD,EAuDhBwC,aAAY,CAACP,SAAQQ,SAAU,IAA9DC,EAvD+C,EAuD/CA,aAAcC,EAvDiC,EAuDjCA,cAErB,OACI,6BACI,mDAEA,kBAACC,GAAA,EAAD,CACIvnB,KAAM,OACNzG,MAAOgrB,EACPiD,SAAU,SAAAjL,GAAC,OAAIiI,EAAkBjI,EAAEW,OAAO3jB,QAC1ColB,WAAS,EACTD,QAAS,WACT+I,YAAa,kDAEO,OAAvBhD,GAA+BA,EAChC,6BACA,kBAAChG,GAAA,EAAD,CACIlM,MAAO,UACPmM,QAAS,YACTE,QAASyG,GAHb,UAQA,gDAEA,yCACQgC,IADR,CAEIzP,MAAO,CACHK,MAAO,OACPN,OAAQ,IACRE,QAAS,OACTO,eAAgB,SAChBC,WAAY,SACZ3X,WAAYM,MAGhB,0BAAWsmB,KACX,gFAEa,OAAhBjD,GAAwBA,EAEzB,gDAEA,kBAAC5F,GAAA,EAAD,CACIlM,MAAO,UACPmM,QAAS,YACTE,QAAS4G,GAHb,YC1ICkC,GAAQ,SAACjQ,GAClB,IAAMkQ,EAAQnM,aAAYvE,IAE1B,OACI,6BACI,qCACA,6IACA,4BACK0Q,EAAM5rB,KAAI,SAACuY,EAAG3b,GAAJ,OAAU,wBAAIwC,IAAKxC,GAAI2b,SCSrC+J,GAAmB,oBAE1BuJ,GAAa9R,GAAa,qFAEzB,SAAS+R,KAAM,IAAD,QACiBxO,IAAMC,UAAS,GADhC,mBACVwO,EADU,KACCC,EADD,OAE+B1O,IAAMC,UAAS,GAF9C,mBAEV0O,EAFU,KAEQC,EAFR,OAG+B5O,IAAMC,UAAS,GAH9C,mBAGV4O,EAHU,KAGQC,EAHR,OAIe9O,IAAMC,UAAS,GAJ9B,mBAIV8O,EAJU,KAIAC,EAJA,KAKXlK,EAAWC,aAAcC,IAEzBiK,EAAY9M,cAAY,SAAC5E,GAAD,OAAkBA,EAAM0R,aAChDC,EAAc/M,cAAY,SAAC5E,GAAD,mCAAkBA,EAAMC,YAAxB,aAAkB,EAAY2R,cAA9B,QAAwC,QAClEC,EAAajN,cAAY,SAAC5E,GAAD,mCAAkBA,EAAMC,YAAxB,aAAkB,EAAY4R,kBAA9B,QAA4C,MACrEhN,EAAgBD,cAAY,SAAC5E,GAAD,OAAkBA,EAAM6E,iBACpDhD,EAAgB+C,cAAY,SAAC5E,GAAD,OAAkBA,EAAM6B,iBACpDjc,EAAQgf,cAAY,SAAC5E,GAAD,mCAAkBA,EAAMC,YAAxB,aAAkB,EAAYra,aAA9B,QAAuCorB,MAC3Dc,EAAgBlN,cAAY,SAAC5E,GAAD,mCAAkBA,EAAMC,YAAxB,aAAkB,EAAY6R,qBAA9B,QAA+C,QAE3EnN,EAAgBC,aAAY9E,IAC5BiS,EAAanN,aAAYxE,IACzBE,EAAWsE,aAAYzE,IAEvB6R,EAAevP,IAAM0C,aAAY,WACnCH,GAAQgN,aAAarN,KACtB,CAACA,IAEEsN,EAAcxP,IAAM0C,aAAY,WAClCgM,GAAa,SAAA9uB,GAAC,OAAKA,OACpB,IAEG6vB,EAAazP,IAAM0C,aAAY,SAACtc,EAAenD,GACjDsf,GAAQmN,SAAStpB,EAAOnD,EAAQif,KACjC,CAACA,IAEEyN,EAAgB3P,IAAM0C,aAAY,SAACtc,GACjC0e,GAAY1C,EAAc7iB,OAAS,EACnCgjB,GAAQmN,SAAStpB,EAAOgc,EAAeF,GAEvCK,GAAQqN,YAAYxpB,KAEzB,CAAC0e,EAAU1C,EAAeF,IAEvB2N,EAAgB7P,IAAM0C,aAAY,WACpCH,GAAQa,iBAAiB,MAC1B,IAEG0M,EAAkB9P,IAAM0C,aAAY,SAACQ,GAOvC,GAN2B,MAAxBA,EAAEphB,IAAIiuB,eAAuBxN,GAAQyN,aAAa,SAC1B,MAAxB9M,EAAEphB,IAAIiuB,eAAuBxN,GAAQyN,aAAa,cAC1B,MAAxB9M,EAAEphB,IAAIiuB,eAAuBxN,GAAQ0N,OACb,MAAxB/M,EAAEphB,IAAIiuB,eAAuBR,IACL,MAAxBrM,EAAEphB,IAAIiuB,eAAuBP,IACL,MAAxBtM,EAAEphB,IAAIiuB,eAAuBF,IAC7B,KAAKK,KAAKhN,EAAEphB,KAAK,CAChB,IAAM0G,EAAS2nB,SAASjN,EAAEphB,IAAK,IAC5B0G,GAAU,GAAKA,GAAU,IACrB4Z,EAAc7iB,OAAS,EACtBkwB,EAAWjnB,EAAQ4Z,GAEnBuN,EAAcnnB,OAI3B,CAAC+mB,EAAcC,EAAaC,EAAYrN,EAAeyN,EAAeF,IAIzE,OAFAhN,aAAiB,UAAWmN,GAGxB,yBAAKvR,MAAO,CAAED,OAAQ,OAAQ4J,UAAW,EAAG1J,QAAS,OAAQO,eAAgB,WACzE,yBAAKR,MAAO,CAAED,OAAQ,OAAQM,MAAO,OAAQ6I,QAAS3C,EAAW,EAAI,GAAIsL,SAAU,MAC/E,yBAAK7R,MAAO,CAAED,OAAQ,OAAQE,QAAS,OAAQiH,cAAe,SAAUzG,WAAY,YAChF,kBAACwI,GAAA,EAAD,CAAOjJ,MAAO,CAAEkJ,QAAS,GAAIC,aAAc,KACvC,yBAAKnJ,MAAO,CAAEC,QAAS,SACnB,yBAAKD,MAAO,CAAEqJ,YAAa,KACvB,kBAACxC,GAAA,EAAD,CAAQlM,MAAM,UAAUmM,QAAQ,YAAYE,QAAS,kBAAMqJ,GAAoB,KAA/E,kBAIJ,6BACI,kBAACxJ,GAAA,EAAD,CAAQlM,MAAM,YAAYmM,QAAQ,YAAYE,QAAS,kBAAMuJ,GAAoB,KAAjF,oBAIJ,yBAAKvQ,MAAO,CAAE0J,KAAM,EAAGzJ,QAAS,OAAQO,eAAgB,aACpD,kBAACqG,GAAA,EAAD,CAAQC,QAAS,WAAYE,QAAS,kBAAMyJ,GAAY,KAAxD,WAMZ,kBAACxH,GAAA,EAAD,CAAOjJ,MAAO,CAAEkJ,QAAS,GAAI4I,YAAavL,EAAW,EAAI,GAAIqE,aAAcrE,EAAW,EAAI,GAAImD,KAAM,WAAYC,UAAW,EAAG1J,QAAS,OAAQiH,cAAe,WACzJ4J,GACD,yBAAK9Q,MAAO,CAAEC,QAAS,OAAQO,eAAgB,SAAUuR,cAAe,KACpE,wBAAI/R,MAAO,CAAEoK,OAAQ,IAArB,WAAmC0G,EAAc/U,KAAjD,kBAAsE+U,EAAcpV,WAAWA,aAGnG,yBAAKsE,MAAO,CAAE0J,KAAM,WAAYC,UAAW,EAAG1J,QAAS,OAAQO,eAAgB,WAC3E,kBAAC,GAAD,CACI5b,MAAO+rB,EAAcA,EAAY/J,iBAAmBhiB,EACpD2c,YAAW,iBAAEoP,QAAF,IAAEA,OAAF,EAAEA,EAAapP,mBAAf,QAA8B,KACzCC,YAAauP,IAAezR,KAGpC,yBAAKU,MAAO,CAAEC,QAAS,OAAQO,eAAgB,SAAUmK,SAAU,OAAQoH,cAAe,KACtF,kBAAClL,GAAA,EAAD,CACIG,QAAS,kBAAMhD,GAAQyN,aAAa,UACpCjI,SAAwB,UAAdkH,EACV5J,QAAS,WACTM,KAAM,QACNpH,MAAK,eACgB,UAAd0Q,EACG,CACE7nB,gB7B1Ff,U6B2Fe8R,MAAO9Q,G7B3FtB,iB6B4FemoB,IAGXzL,EACK,QACA,aAGV,kBAACM,GAAA,EAAD,CACIG,QAAS,kBAAMhD,GAAQyN,aAAa,eACpCjI,SAAwB,eAAdkH,EACV5J,QAAS,WACTM,KAAM,QACNpH,MAAK,eACgB,eAAd0Q,EACG,CACE7nB,gB7B5Gf,U6B6Ge8R,MAAO9Q,G7B7GtB,iB6B8GemoB,IAGXzL,EACK,YACA,iBAGV,kBAACM,GAAA,EAAD,CACIG,QAAShD,GAAQ0N,KACjBlI,SAAgC,IAAtBqH,EAAW7vB,OACrB8lB,QAAS,WACTM,KAAM,SAELb,EACK,OACA,YAGV,kBAACM,GAAA,EAAD,CACIG,QAASsK,EACT9H,SAAmC,IAAzB3F,EAAc7iB,OACxB8lB,QAAS,WACTM,KAAM,SAELb,EACK,eACA,oBAGV,kBAACM,GAAA,EAAD,CACIG,QAASiK,EACTnK,QAAS,WACTM,KAAM,QACNpH,MAAK,eACEkQ,EACG,CACErnB,gB7BnJf,U6BoJe8R,MAAO9Q,G7BpJtB,iB6BqJemoB,IAGXzL,EACK,QACA,aAGV,kBAACM,GAAA,EAAD,CACIG,QAASgK,EACTxH,SAAQ,OAAElK,QAAF,IAAEA,KACVwH,QAAS,WACTM,KAAM,QACNpH,MAAK,eACI2Q,EACC,CACE9nB,gB7BrKf,U6BsKe8R,MAAO9Q,G7BtKtB,iB6BuKemoB,IAGXzL,EACK,SACA,eAId,6BACI,kBAAC,GAAD,CACI3hB,MAAOA,EACPimB,aAAcuG,EACdvQ,cAAeA,QAMlCqP,GACD,kBAACjH,GAAA,EAAD,CACIjJ,MAAK,aACDD,OAAQ,OACRM,MAAO,IACP6I,QAAS,GACTG,YAAa,GACbO,UAAW,QACRrD,EACG,CACElC,SAAU,WACVtE,OAAQ,OACRM,MAAO,OACP+J,OAAQ,GACR6H,MAAO,GACP,KAGZ,kBAAC,GAAD,MACC1L,GACG,kBAACM,GAAA,EAAD,CAAQC,QAAS,WAAYE,QAASiK,GAAtC,YAILN,GACH,kBAAC1H,GAAA,EAAD,CACIjJ,MAAK,aACDD,OAAQ,OACRM,MAAO,IACP6I,QAAS,GACTU,UAAW,QACRrD,EACG,CACElC,SAAU,WACVtE,OAAQ,OACRM,MAAO,OACP+J,OAAQ,EACR6H,MAAO,EACPC,QAAS,OACT,KAGZ,kBAAC,GAAD,CACIttB,MAAK,oBAAE+rB,EAAYpP,mBAAd,aAAE,EAAyB3c,aAA3B,QAAoC+rB,EAAY/J,iBACrDrF,YAAaoP,EAAYpP,YACzB6E,cAAepC,GAAQmO,eACvBlL,eAAgBjD,GAAQoO,kBAIhC,kBAACC,GAAA,EAAD,CACItL,WAAS,EACT8K,SAAUtL,EAAW,KAAO,KAC5B+L,KAAMlC,EACNmC,QAAS,kBAAMlC,GAAoB,KAEnC,kBAACpH,GAAA,EAAD,CAAOjJ,MAAO,CAAEkJ,QAAS,KACrB,kBAAC,GAAD,CACIH,eAAgB,SAAChB,EAAQyK,GACrBxO,GAAQyO,YAAY1K,EAAQyK,GAC5BnC,GAAoB,QAKpC,kBAACgC,GAAA,EAAD,CACItL,WAAS,EACT8K,SAAUtL,EAAW,KAAO,KAC5B+L,KAAM9B,EACN+B,QAAS,kBAAM9B,GAAY,KAE3B,kBAACxH,GAAA,EAAD,CAAOjJ,MAAO,CAAEkJ,QAAS,KACrB,kBAAC,GAAD,QAGR,kBAACmJ,GAAA,EAAD,CACItL,WAAS,EACT8K,SAAUtL,EAAW,KAAO,KAC5B+L,KAAMhC,EACNiC,QAAS,kBAAMhC,GAAoB,KAEnC,kBAACtH,GAAA,EAAD,CAAOjJ,MAAO,CAAEkJ,QAAS,KACrB,kBAAC,GAAD,S,mDCrRdwJ,GAAsB,CACxBjT,QAAS,GACTE,SAAU,CACN6I,OAAQ,GACRb,OAAQ,GACRgB,SAAU,IAEd1J,KAAM,KACNyR,UAAW,QACX7M,cAAe,GACfhD,cAAe,MC3Cb8R,GAAc,SAACC,GAWjB,OAVIA,EAAKpK,SACLoK,EAAKpK,OAAS,IAEdoK,EAAKjK,WACLiK,EAAKjK,SAAW,IAEhBiK,EAAKjL,SACLiL,EAAKjL,OAAS,IAGXiL,GAeLC,GAAkB,SAAClxB,GACrB,IACImxB,aAAaC,QAAQ,UAfVH,EAe8BjxB,EAdtCurB,KAAK6B,UAAU6D,KAerB,MAAMpF,IAhBO,IAACoF,GCDbI,GAAU,CACZC,MDsByB,SAACL,GAC1BC,GAAgBD,KCpBdM,GAAaC,2BF+CoB,SAACH,GAAD,OAAsB,SAAAC,GACzD,IAAIG,EAAeH,EAAMI,WAAW1T,SACpC,OAAO,SAAAje,GAAI,OAAI,SAAA4xB,GACX5xB,EAAK4xB,GACL,IAAMC,EAAeN,EAAMI,WAAW1T,SAClCyT,IAAiBG,IACjBP,EAAQC,MAAMM,GACdH,EAAeG,MEtDQC,CAAwBR,KACrDS,GAAWC,+BAAoBR,IACxBD,GAAQU,wBF+BE,WAAkD,IAAjD3U,EAAgD,uDAAjC0T,GAAcY,EAAmB,uCACpE,OAAO,2BACAtU,GACyB,oBAAjBsU,EAAOtU,MAAuBsU,EAAOtU,MAAMA,GAASsU,EAAOtU,SElCpCyU,IAC7BzP,GF8DgB,SAAA4P,GACzB,IAAMC,EAAW,SAACzrB,EAAc4W,GAAf,OAAmC4U,EAAU,CAAE5U,QAAO5W,UAkKvE,MAAO,CACH0rB,WAhKe,SAACrU,GAAD,OAA8BoU,EAAS,aAAc,CAAEpU,aAiKtE8N,YAhKgB,SAAC5N,GAAD,OAAwBkU,EAAS,cAAe,CAAElU,cAiKlE0R,YAhKgB,SAACxpB,GAAD,OAAmBgsB,EAAS,YAAY,SAAA7U,GACxD,MAAO,CACH6B,cAAe7B,EAAM6B,gBAAkBhZ,EAAQ,KAAOA,OA+J1Dgd,iBA5JqB,SAAChB,GAAD,OAA4BgQ,EAAS,mBAAoB,CAAEhQ,mBA6JhFI,gBA5JoB,SAAC7c,GAAD,OAAiBysB,EAAS,mBAAmB,SAAA7U,GACjE,MAAO,CACH6E,cAAe1hB,EAAS,GAAD,mBAAK6c,EAAM6E,eAAX,CAA0Bzc,IAAOvD,QA2J5DkwB,UAvJc,SAACnvB,EAAcksB,GAAf,OAAgD+C,EAAS,aAAa,SAAA7U,GAAU,IAAD,IAC7F,MAAO,CACHC,KAAM,CACFC,aAActa,EACdA,QACAksB,gBACAD,WAAY,GACZD,OAAyC,QAAjC,oBAAC5R,EAAMC,YAAP,aAAC,EAAY2R,cAAb,QAAuB,MACzB,CACEhK,iBAAkBhI,GAAsBha,GACxC2c,YAAa,MAEf,MAEVsC,cAAe,GACfhD,cAAe,UAyInB4R,YArIgB,SAACuB,EAAyBxB,GAA1B,OAAoDqB,EAAS,gBAAgB,SAAA7U,GAAU,IAAD,MAChGiV,EAAgB/V,GAAa8V,EAASvL,WACtCE,EAAW6J,GAAY,UAAGxT,EAAMW,SAASgJ,SAASqL,EAASvL,kBAApC,QAAyD,KAChF7jB,EAAQ+jB,GAAsBsL,EAEpC,MAAO,CACHhV,KAAM,CACFC,aAActa,EACdA,QACAksB,cAAekD,EACfnD,WAAY,GACZD,OAAyC,QAAjC,oBAAC5R,EAAMC,YAAP,aAAC,EAAY2R,cAAb,QAAuB,MACzB,CACEhK,iBAAkBhI,GAAsBha,GACxC2c,YAAa,MAEf,MAEVsC,cAAe,GACfhD,cAAe,UAmHnBmQ,aA/GiB,SAACrN,GAAD,OAAiCkQ,EAAS,gBAAgB,SAAA7U,GAC3E,OAAKA,EAAMC,MAAS0E,EAEhB3E,EAAMC,KAAK2R,OACJ,CACH3R,KAAK,2BACED,EAAMC,MADT,IAEA2R,OAAQ,QAIZ9oB,GAAckX,EAAMC,KAAKra,MAAO+e,GACzB3E,EAEJ,CACHC,KAAK,2BACED,EAAMC,MADT,IAEA2R,OAAQ,CACJhK,iBAAkBhI,GAAsBI,EAAMC,KAAKra,OACnD2c,YAAa,QAGrBsC,cAAe,GACfhD,cAAe,MAtBmB7B,MA+G1CmT,eApFmB,SAAC5Q,EAAiCqF,GAAlC,OAA8DiN,EAAS,kBAAkB,SAAA7U,GAC5G,OAAIA,EAAMC,KAEH,CACHA,KAAK,2BACED,EAAMC,MADT,IAEA2R,OAAQ,CACJhK,mBACArF,kBAPWvC,MAoFvBoT,eAvEmB,kBAAMyB,EAAS,kBAAkB,SAAA7U,GACpD,OAAKA,EAAMC,MAASD,EAAMC,KAAK2R,OAIxB,CACH3R,KAAK,2BACED,EAAMC,MADT,IAEA4R,WAAW,CAAE7R,EAAMC,KAAKra,OAAd,mBAAwBoa,EAAMC,KAAK4R,aAC7CjsB,MAAOoa,EAAMC,KAAK2R,OAAOhK,iBACzBgK,OAAQ,QARL5R,MAsEXmS,SAzDa,SAACtpB,EAAenD,EAAiBif,GAAjC,OAAiEkQ,EAAS,YAAY,SAAA7U,GACnG,IAAKA,EAAMC,OAAS0E,GAAiB3E,EAAMC,KAAK2R,OAAQ,OAAO5R,EAE/D,IA9HMiO,EAAK1pB,EA8HLqB,EAAQ6Z,GAAgBO,EAAMC,KAAKra,MAAOF,EAAQmD,EAAOmX,EAAM0R,WAC/DwD,EbxKY,SAACtvB,GAEvB,IADA,IAAIsvB,EAAW,GACP1vB,EAAI,EAAGA,EAAI,EAAGA,IAClB,IAAI,IAAInD,EAAI,EAAGA,EAAI,EAAGA,IAAI,CACtB,IAAM+F,EAAOxC,EAAMJ,GAAGnD,GACtB6yB,GAA2B,OAAf9sB,EAAKzF,MAAiB,IAAMyqB,OAAOhlB,EAAKzF,OAG5D,OAAOuyB,EagKcC,CAAWnV,EAAMC,KAAKC,cAEnCS,EAAWX,EAAMW,SAiBrB,MAAO,CACHA,SAhBAA,EADD3X,GAAgBpD,KAAWkD,GAAclD,EAAO+e,GACvC,2BACDhE,GADC,IAEJ6I,OAAO,CAAE0L,GAAH,mBAAgBvU,EAAS6I,SAC/BG,UAtIFsE,EAsIiBtN,EAASgJ,SAtIrBplB,EAsI+B2wB,SArI9CjH,EAAG,eAAOA,IACC1pB,GACJ0pB,KAsIS,2BACDtN,GADC,IAEJgJ,SAAS,2BACFhJ,EAASgJ,UADR,kBAEHuL,EAAWtvB,MAOpBqa,KAAK,2BACED,EAAMC,MADT,IAEAra,QACAisB,WAAW,CAAE7R,EAAMC,KAAKra,OAAd,mBAAwBoa,EAAMC,KAAK4R,oBA8BrDY,aA5KiB,SAACf,GAAD,OAA0BmD,EAAS,eAAgB,CAAEnD,eA6KtEgB,KA1BS,kBAAMmC,EAAS,QAAQ,SAAA7U,GAChC,OAAKA,EAAMC,MAAQD,EAAMC,KAAK2R,QACO,IAAjC5R,EAAMC,KAAK4R,WAAW7vB,OADmBge,EAGtC,CACHC,KAAK,2BACED,EAAMC,MADT,IAEAra,MAAOoa,EAAMC,KAAK4R,WAAW,GAC7BA,WAAY7R,EAAMC,KAAK4R,WAAWtqB,MAAM,WE5NjC6tB,CAAcnB,GAAMW,UAE3C5P,GAAQuJ,YDJgB,WACpB,IAAI,IAAD,EACOqF,EAAO1F,KAAKC,MAAL,UAAW2F,aAAauB,QAAQ,iBAAhC,QAA6C,MAC1D,OAAO1B,GAAYC,GACtB,MAAMpF,GACH,OAAOmF,GAAY,KAWhB2B,ICVXC,MAAMC,+BACDC,MAAK,SAAApzB,GAAC,OAAIA,EAAEmH,UACZisB,MAAK,SAAApzB,GAAC,OAAIA,EACNkd,MAAM,MACNxc,QAAO,SAAAuE,GAAI,OAA2B,IAAvBA,EAAKglB,OAAOtqB,UAC3BmD,KAAI,SAAAmC,GAAI,OAAI4mB,KAAKC,MAAM7mB,SAE3BmuB,MAAK,SAAAnN,GAAU,OAAItD,GAAQ8P,WAAWxM,MAE3CoN,IAASC,OACP,kBAAC,IAAMC,WAAP,KACI,kBAACC,GAAA,EAAD,CAAe5sB,MAAOA,IAClB,kBAAC6sB,GAAA,EAAD,KACI,kBAAC,KAAD,CAAe7B,MAAOA,IACpB,kBAAChD,GAAD,UAKd1K,SAASwP,eAAe,U","file":"static/js/main.78794d65.chunk.js","sourcesContent":["export const getCombinations = <T>(items: T[], len: number, initIndex = 0): T[][] => {\r\n    if(len === 0) return []\r\n    const combos: T[][] = []\r\n    // NB: Stop loop before it gets so far as to not have enough items left for a full combo\r\n    for(let i = initIndex; i < items.length-len+1; i++){\r\n        const rest = getCombinations(items, len - 1, i + 1)\r\n        if(rest.length === 0){\r\n            combos.push([items[i]])\r\n        }\r\n        for(let combo of rest){\r\n            combos.push([items[i], ...combo])\r\n        }\r\n    }\r\n    return combos\r\n}\r\n\r\nconst isNotNull = <T>(x: T): x is Exclude<T, null> => x !== null\r\n\r\nexport const first = <T>(iterable: Iterable<T | null>): T | null => iterable[Symbol.iterator]().next().value\r\nexport const allResults = <T>(iterable: Iterable<T | null>): T[] =>\r\n    Array.from(iterable).filter(isNotNull)\r\n\r\nexport const unique = <T>(arr: T[]): T[] => [...new Set(arr)]\r\nexport const uniqueBy = <T>(arr: T[], isEqual): T[] => {\r\n    const result: T[] = []\r\n    arr.forEach(a => {\r\n        if(!result.some(b => isEqual(a, b))){\r\n            result.push(a)\r\n        }\r\n    })\r\n    return result\r\n}\r\nexport const difference = <T>(arr1: T[], arr2: T[], isEqual): T[] => {\r\n    return arr1.filter(a => !arr2.some(b => isEqual(a, b)))\r\n}\r\nexport const intersectionOfAll = <T>(arr: T[][], isEqual): T[] => {\r\n    return uniqueBy(arr.flat(), isEqual).filter(x => arr.every(subArr => subArr.some(a => isEqual(a, x))))\r\n}\r\nexport const arraysEqual = (arr1, arr2, isEqual = (a, b) => a === b) => {\r\n    return arr1.length === arr2.length && arr1.every((a, i) => isEqual(a, arr2[i]))\r\n}\r\ntype Groups<T> = {[key: string]: T[]}\r\nexport const groupBy = <T>(arr: T[], by): Groups<T> => {\r\n    return arr.reduce((groups, item) => {\r\n        const key = by(item)\r\n        groups[key] = (groups[key] ?? [])\r\n        groups[key].push(item)\r\n        return groups\r\n    }, {})\r\n}\r\n\r\nexport const memoize = <T extends Function>(fn: T, getKey): T => {\r\n    let memo = {}\r\n    return ((...args) => {\r\n        const key = getKey(...args)\r\n        if(memo.hasOwnProperty(key)) return memo[key]\r\n        const result = fn(...args)\r\n        memo[key] = result\r\n        return result\r\n    }) as unknown as T\r\n}\r\n\r\nexport const rand = (n: number) => Math.floor((Math.random()*n))\r\nexport const randIndex = list => rand(list.length)\r\n\r\nexport const randomOrder = (list) => {\r\n    list = [...list]\r\n    for(let i = 0; i < list.length; i++){\r\n        const ri = randIndex(list)\r\n        const tmp = list[i]\r\n        list[i] = list[ri]\r\n        list[ri] = tmp\r\n    }\r\n    return list\r\n}","import { Point, Board, Cell, TechniqueResult, Effect } from '../types'\r\nimport { arraysEqual, difference, intersectionOfAll, memoize } from './misc'\r\n\r\nexport const pointsEqual = (pointA: Point, pointB: Point) => pointA.id === pointB.id\r\nexport const pointListsEqual = (pointsA: Point[], pointsB: Point[]) => arraysEqual(pointsA, pointsB, pointsEqual)\r\n\r\nexport const allCandidates = Array(9).fill(0).map((_, i) => i + 1)\r\n\r\nexport const candidatesExcept = (cands: number[]) => difference(allCandidates, cands, (a,b) => a === b)\r\n\r\nexport const getPointId = (x, y) => y * 9 + x\r\n\r\nexport const getAllPoints = memoize((): Point[] => {\r\n    const points: Point[] = []\r\n    for(let x = 0; x < 9; x++){\r\n        for(let y = 0; y < 9; y++){\r\n            points.push({x, y, id: getPointId(x, y)})\r\n        }\r\n    }\r\n    return points\r\n}, () => '')\r\n\r\nexport const getAllUnfilledPoints = (board: Board): Point[] => getAllPoints().filter(p => getBoardCell(board, p).value === null)\r\n\r\nexport const getColumn = memoize((x: number): Point[] => {\r\n    const col: Point[] = []\r\n    for(let y = 0; y < 9; y++){\r\n        col.push({x, y, id: getPointId(x, y)})\r\n    }\r\n    return col\r\n}, (x) => x)\r\n\r\nexport const getRow = memoize((y: number): Point[] => {\r\n    const row: Point[] = []\r\n    for(let x = 0; x < 9; x++){\r\n        row.push({x, y, id: getPointId(x, y)})\r\n    }\r\n    return row\r\n}, y => y)\r\n\r\nexport const getBox = memoize((point: Point): Point[] => {\r\n    const box: Point[] = []\r\n    const xStart = Math.floor(point.x/3)*3\r\n    const yStart = Math.floor(point.y/3)*3\r\n    for(let x = xStart; x < xStart + 3; x++){\r\n        for(let y = yStart; y < yStart + 3; y++){\r\n            box.push({x, y, id: getPointId(x, y)})\r\n        }\r\n    }\r\n    return box\r\n}, p => `${p.x}-${p.y}`)\r\n\r\nexport const getAllRows = memoize((): Point[][] => {\r\n    const rows: Point[][] = []\r\n    for(let y = 0; y < 9; y++){\r\n        rows.push(getRow(y))\r\n    }\r\n    return rows\r\n}, () => 'T')\r\n\r\nexport const getAllCols = memoize((): Point[][] => {\r\n    const cols: Point[][] = []\r\n    for(let x = 0; x < 9; x++){\r\n        cols.push(getColumn(x))\r\n    }\r\n    return cols\r\n}, () => 'T')\r\n\r\nexport const getBoxX = (boxNumber: number) => (boxNumber % 3) * 3\r\nexport const getBoxY = (boxNumber: number) => Math.floor(boxNumber / 3) * 3\r\n\r\nexport const getAllBoxes = memoize((): Point[][] => {\r\n    const boxes: Point[][] = []\r\n    for(let k = 0; k < 9; k++){\r\n        const x = getBoxX(k)\r\n        const y = getBoxY(k)\r\n        boxes.push(getBox({x, y, id: getPointId(x, y)}))\r\n    }\r\n    return boxes\r\n}, () => 'T')\r\n\r\nexport const getAllHouses = memoize((): Point[][] => {\r\n    return [\r\n        ...getAllRows(),\r\n        ...getAllCols(),\r\n        ...getAllBoxes()\r\n    ]\r\n}, () => 'T')\r\n\r\nexport const getBoxGroups = memoize(() => {\r\n    const groups: Point[][] = []\r\n    for(let line of [...getAllRows(), ...getAllCols()]){\r\n        groups.push(\r\n            line.slice(0, 3),\r\n            line.slice(3, 6),\r\n            line.slice(6, 9)\r\n        )\r\n    }\r\n    return groups\r\n}, () => 'T')\r\n\r\nexport const getAllHousesMinusFilledPoints = (board: Board): Point[][] => getAllHouses()\r\n    .map(points => points.filter(p => getBoardCell(board, p).value === null))\r\n    .filter(points => points.length > 0)\r\n\r\nexport const getAffectedPoints = (point: Point): Point[] => {\r\n    return [\r\n        ...getColumn(point.x),\r\n        ...getRow(point.y),\r\n        ...getBox(point)\r\n    ].filter(p => !pointsEqual(p, point))\r\n}\r\n\r\nexport const pointsSeeEachOther = (point1: Point, point2: Point) => {\r\n    return point1.x === point2.x || point1.y === point2.y || getBoxNumber(point1) === getBoxNumber(point2)\r\n}\r\n\r\nexport const getRowsOutsideBox = boxNumber => {\r\n    const boxY = getBoxY(boxNumber)\r\n    return getAllRows().filter(points => points[0].y < boxY || points[0].y >= boxY + 3)\r\n}\r\nexport const getColsOutsideBox = boxNumber => {\r\n    const boxX = getBoxX(boxNumber)\r\n    return getAllCols().filter(points => points[0].x < boxX || points[0].x >= boxX + 3)\r\n}\r\n\r\n// Finds every point which \"sees\" all of the given points\r\nexport const getAffectedPointsInCommon = (points: Point[]): Point[] => {\r\n    return intersectionOfAll(points.map(getAffectedPoints), pointsEqual)\r\n}\r\n\r\nexport const getRowNumber = (point: Point) => point.y\r\nexport const getColNumber = (point: Point) => point.x\r\nexport const getBoxNumber = (point: Point) => (Math.floor(point.x / 3)) + (3 * Math.floor(point.y/3))\r\n\r\nexport const getBoardCell = (board: Board, point: Point) => board[point.y][point.x]\r\n\r\nexport const isBoardFinished = (board: Board) => {\r\n    return getAllPoints().every(point => getBoardCell(board, point).value !== null)\r\n}\r\n\r\nexport const cloneBoard = (board: Board) => {\r\n    return [...board].map(row => [...row].map(cell => {\r\n        return {\r\n            ...cell,\r\n            candidates: [...cell.candidates]\r\n        }\r\n    }))\r\n}\r\n\r\nexport const pointsWhere = (board: Board, points: Point[], filter: (cell: Cell) => boolean): Point[] =>\r\n    points.filter(point => filter(getBoardCell(board, point)))\r\n\r\nexport const getPointsWithCandidates = (board: Board, points: Point[], cands: number[]) =>\r\n    pointsWhere(board, points, (cell) => cands.every(cand => cell.candidates.includes(cand)))\r\n\r\nexport const getPointsWithNCandidates = (board: Board, points: Point[], n: number) =>\r\n    pointsWhere(board, points, (cell) => cell.candidates.length === n)\r\n\r\nexport const canPutDigit = (board: Board, point: Point, digit: number) => {\r\n    const affected = getAffectedPoints(point)\r\n    return !affected.some(p => getBoardCell(board, p).value === digit)\r\n}\r\n\r\nexport const boardHasError = (board: Board, solution: Board) => {\r\n    return !getAllPoints().every(point => {\r\n        const value = getBoardCell(board, point).value\r\n        return value === null || getBoardCell(solution, point).value === value\r\n    })\r\n}\r\n\r\nexport const boardIsComplete = (board: Board) => {\r\n    return getAllPoints().every(point => getBoardCell(board, point).value !== null)\r\n}\r\n\r\nexport const mergeResults = <T extends Effect>(results: TechniqueResult<T>[]) => {\r\n    return results.reduce((allResults, result) => {\r\n        allResults.effects.push(...result.effects)\r\n        allResults.actors.push(...result.actors)\r\n        return allResults\r\n    }, {effects: [], actors: []} as TechniqueResult<T>)\r\n}","import { createMuiTheme, darken, lighten } from '@material-ui/core/styles'\r\n\r\nexport const theme = createMuiTheme({\r\n    palette: {\r\n        type: 'dark',\r\n        primary: {\r\n            main: '#72d282',\r\n        },\r\n        secondary: {\r\n            main: '#80DEEA',\r\n        },\r\n        text: {\r\n            primary: '#efefef'\r\n        },\r\n    },\r\n    typography: {\r\n        button: {\r\n            textTransform: 'none'\r\n        }\r\n    }\r\n})\r\n\r\nexport const textColor = theme.palette.text.primary\r\nexport const backgroundColor = theme.palette.background.paper\r\nexport const backgroundDisabledColor = lighten(theme.palette.background.paper, 0.2)\r\nexport const borderHardColor = darken(textColor, 0.5)\r\n\r\nexport const boardBackgroundColor = lighten(theme.palette.background.paper, 0.1)\r\nexport const boardBorderColor = '#444'\r\nexport const boardBorderHardColor = '#333'\r\n\r\n/*\r\nLight\r\nexport const actorColor = '#c5f6b0'\r\nexport const setValueColor = '#85ffff'\r\nexport const eliminationColor = '#b0c9f6'\r\nexport const selectedColor = '#ffc0b0'\r\nexport const affectedColor = backgroundSecondaryColor\r\nexport const highlightedColor = '#ffc0b0'\r\nexport const selectedDigitHighlightColor = '#ffd0b0'\r\nexport const errorColor = '#fc4444'\r\n */\r\n\r\nexport const actorColor = '#d3bef8'\r\nexport const setValueColor = '#94fa96'\r\nexport const eliminationColor = '#f67467'\r\nexport const selectedColor = darken(theme.palette.primary.main, 0.3)\r\nexport const affectedColor = darken(selectedColor, 0.3)\r\nexport const highlightedColor = selectedColor\r\nexport const highlightedCandidateColor = lighten(selectedColor, 0.15)\r\nexport const selectedDigitHighlightColor = '#66c187'\r\nexport const errorColor = '#fc4444'\r\n\r\nexport const setCandidateColor = darken(setValueColor, 0.1)\r\nexport const eliminateCandidateColor = darken(eliminationColor, 0.2)\r\nexport const actorCandidateColor = darken(actorColor, 0.2)\r\nexport const actorChainCandidateYesColor = darken(setValueColor, 0.2)\r\nexport const actorChainCandidateNoColor = '#2475ff'\r\n\r\nexport const getContrastText = theme.palette.getContrastText","import {\r\n    AddCandidatesEffect,\r\n    Board,\r\n    Effect,\r\n    EliminationEffect, GroupEffect,\r\n    NoneEffect,\r\n    Point,\r\n    RemoveValueEffect,\r\n    SetValueEffect\r\n} from '../types'\r\nimport { cloneBoard, getAffectedPoints, getBoardCell, pointsEqual } from './sudokuUtils'\r\nimport { arraysEqual, unique, uniqueBy } from './misc'\r\n\r\nexport const removeCandidates = (board: Board, point: Point, numbers: number[]): EliminationEffect | NoneEffect => {\r\n    const cell = getBoardCell(board, point)\r\n    const candidatesToRemove = cell.candidates.filter(x => numbers.includes(x))\r\n    if(candidatesToRemove.length === 0 || cell.value !== null){\r\n        return {type: 'none'} as NoneEffect\r\n    }\r\n    return {type: 'elimination', point, numbers: candidatesToRemove}\r\n}\r\n\r\nexport const addCandidates = (board: Board, point: Point, numbers: number[]): AddCandidatesEffect | NoneEffect => {\r\n    const cell = getBoardCell(board, point)\r\n    const candidatesToAdd = numbers.filter(x => !cell.candidates.includes(x))\r\n    if(candidatesToAdd.length === 0 || cell.value !== null){\r\n        return {type: 'none'} as NoneEffect\r\n    }\r\n    return {type: 'addCandidates', point, numbers: candidatesToAdd}\r\n}\r\n\r\nexport const effectsEqual = (eff1: Effect | GroupEffect, eff2: Effect | GroupEffect) => {\r\n    if(eff1.type === 'value' && eff2.type === 'value'){\r\n        return pointsEqual(eff1.point, eff2.point) && eff1.number === eff2.number\r\n    }else if(eff1.type === 'elimination' && eff2.type === 'elimination'){\r\n        return pointsEqual(eff1.point, eff2.point) && arraysEqual(eff1.numbers, eff2.numbers, (a, b) => a === b)\r\n    }else if(eff1.type === 'group-elimination' && eff2.type === 'group-elimination'){\r\n        return eff1.groupId === eff2.groupId && eff1.number === eff2.number\r\n    }else if(eff1.type === 'group-value' && eff2.type === 'group-value'){\r\n        return eff1.groupId === eff2.groupId && eff1.number === eff2.number\r\n    }\r\n    return false\r\n}\r\n\r\nexport const uniqueEffects = <T extends Effect | GroupEffect>(effects: T[]) => uniqueBy(effects, effectsEqual)\r\n\r\nexport const removeCandidatesFromPoints = (board: Board, points: Point[], numbers: number[]): EliminationEffect[] => {\r\n    const effects = points\r\n        .map(point => removeCandidates(board, point, numbers))\r\n        .filter(eff => eff.type !== 'none') as EliminationEffect[]\r\n\r\n    return uniqueEffects(effects)\r\n}\r\n\r\nexport const addCandidatesToPoints = (board: Board, points: Point[], numbers: number[]): AddCandidatesEffect[] => {\r\n    return points\r\n        .map(point => addCandidates(board, point, numbers))\r\n        .filter(eff => eff.type !== 'none') as AddCandidatesEffect[]\r\n}\r\n\r\nexport const removeCandidateFromPoints = (board: Board, points: Point[], number: number): EliminationEffect[] => {\r\n    return removeCandidatesFromPoints(board, points, [number])\r\n}\r\n\r\nexport const removeCandidateFromAffectedPoints = (board: Board, point: Point, number: number): EliminationEffect[] => {\r\n    return removeCandidateFromPoints(board, getAffectedPoints(point), number)\r\n}\r\n\r\nexport const toggleCandidate = (board: Board, points: Point[], digit: number): AddCandidatesEffect[] | EliminationEffect[] => {\r\n    const addCand = !points.every(p => {\r\n        const cell = getBoardCell(board, p)\r\n        return cell.value !== null || cell.candidates.includes(digit)\r\n    })\r\n\r\n    if(addCand){\r\n        return addCandidatesToPoints(board, points, [digit])\r\n    }else{\r\n        return removeCandidatesFromPoints(board, points, [digit])\r\n    }\r\n}\r\n\r\nexport const toggleValue = (board: Board, point: Point, digit: number): (SetValueEffect | EliminationEffect)[] | RemoveValueEffect[] => {\r\n    const cell = getBoardCell(board, point)\r\n    if(cell.given){\r\n        return []\r\n    }\r\n    if(cell.value === digit){\r\n        return [{type: 'value', point, number: null}]\r\n    }else{\r\n        return [\r\n            {type: 'value', point, number: digit},\r\n            ...removeCandidateFromAffectedPoints(board, point, digit)\r\n        ]\r\n    }\r\n}\r\n\r\nexport const applyEffects = (board: Board, effects: Effect[]) => {\r\n    board = cloneBoard(board)\r\n\r\n    effects.forEach(effect => {\r\n        if(effect.type === 'elimination') {\r\n            board[effect.point.y][effect.point.x].candidates = board[effect.point.y][effect.point.x].candidates.filter(c => !effect.numbers.includes(c))\r\n        }else if(effect.type === 'addCandidates'){\r\n            board[effect.point.y][effect.point.x].candidates.push(...effect.numbers)\r\n            board[effect.point.y][effect.point.x].candidates = unique(board[effect.point.y][effect.point.x].candidates)\r\n        }else if(effect.type === 'value'){\r\n            board[effect.point.y][effect.point.x].value = effect.number\r\n            board[effect.point.y][effect.point.x].candidates = []\r\n        }\r\n    })\r\n\r\n    return board\r\n}\r\n","import { SolverBoard } from '../types'\r\nimport { removeCandidateFromAffectedPoints } from '../utils/effects'\r\nimport { allResults, first  } from '../utils/misc'\r\nimport { getAllPoints, getBoardCell } from '../utils/sudokuUtils'\r\n\r\n/**\r\n * Just removes candidates from row, col, and box where the candidate is set as a value.\r\n * I.e. Use only the basic constraints of sudoku.\r\n */\r\nfunction *basicEliminationsGenerator(board: SolverBoard){\r\n    for(let point of getAllPoints()){\r\n        const cell = getBoardCell(board, point)\r\n        if(cell.value === null){\r\n            continue\r\n        }\r\n\r\n        const effects = removeCandidateFromAffectedPoints(board, point, cell.value)\r\n        const actors = [{point}]\r\n\r\n        if(effects.length > 0){\r\n            yield {effects, actors}\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const basicElimination = (board: SolverBoard) => first(basicEliminationsGenerator(board))\r\nexport const allBasicEliminations = (board: SolverBoard) => allResults(basicEliminationsGenerator(board))","import { SetValueEffect, SolverBoard } from '../types'\r\nimport { getAllHousesMinusFilledPoints, getAllPoints, getBoardCell, pointsEqual } from '../utils/sudokuUtils'\r\nimport { removeCandidateFromAffectedPoints } from '../utils/effects'\r\nimport { allResults, difference, first } from '../utils/misc'\r\n\r\nfunction *fullHouseGenerator(board: SolverBoard){\r\n    for(let points of getAllHousesMinusFilledPoints(board)){\r\n        if(points.length === 1){\r\n            const point = points[0]\r\n            const cell = getBoardCell(board, point)\r\n            const candidates = cell.candidates\r\n            if(candidates.length === 1){ // Should always be true, but whatever...\r\n                yield {\r\n                    actors: [{point}],\r\n                    effects: [\r\n                        {type: 'value', point, number: cell.candidates[0]} as SetValueEffect,\r\n                        ...removeCandidateFromAffectedPoints(board, point, cell.candidates[0])\r\n                    ]\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * There is only one candidate in a cell. Can be filled immediately.\r\n */\r\nfunction *nakedSingleGenerator(board: SolverBoard){\r\n    for(let point of getAllPoints()){\r\n        const cell = getBoardCell(board, point)\r\n        if(cell.candidates.length === 1){\r\n            yield {\r\n                actors: [{point}],\r\n                effects: [\r\n                    {type: 'value', point, number: cell.candidates[0]} as SetValueEffect,\r\n                    ...removeCandidateFromAffectedPoints(board, point, cell.candidates[0])\r\n                ]\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * The candidate is only in one position in the box, row, or column, and is hidden among other candidates\r\n * All naked singles must be eliminated first or else we find them as hidden singles\r\n */\r\nfunction *hiddenSingleGenerator(board: SolverBoard){\r\n    for(let points of getAllHousesMinusFilledPoints(board)){\r\n        for(let cand = 1; cand <= 9; cand++){\r\n            const pointsWithCand = points.filter(p => getBoardCell(board, p).candidates.some(c => c === cand))\r\n            if(pointsWithCand.length === 1){\r\n                const point = pointsWithCand[0]\r\n                if(getBoardCell(board, point).candidates.length > 1){ // Otherwise it is naked\r\n                    yield {\r\n                        effects: [\r\n                            {type: 'value', point, number: cand} as SetValueEffect,\r\n                            ...removeCandidateFromAffectedPoints(board, point, cand)\r\n                        ],\r\n                        actors: difference(points, [point], pointsEqual).map(point => ({point}))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const fullHouse = (board: SolverBoard) => first(fullHouseGenerator(board))\r\nexport const allFullHouses = (board: SolverBoard) => allResults(fullHouseGenerator(board))\r\n\r\nexport const nakedSingle = (board: SolverBoard) => first(nakedSingleGenerator(board))\r\nexport const allNakedSingles = (board: SolverBoard) => allResults(nakedSingleGenerator(board))\r\n\r\nexport const hiddenSingle = (board: SolverBoard) => first(hiddenSingleGenerator(board))\r\nexport const allHiddenSingles = (board: SolverBoard) => allResults(hiddenSingleGenerator(board))","import { SolverBoard, Point } from '../types'\r\nimport {\r\n    getAllBoxes, getAllCols, getAllRows, getBox, getBoxNumber,\r\n    getColNumber,\r\n    getColumn,\r\n    getPointsWithCandidates, getRow,\r\n    getRowNumber,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { allResults, difference, first, unique } from '../utils/misc'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\n\r\n/**\r\n * If all of a certain candidate within a box are on the same col or row, the rest of the col or row can be eliminated\r\n */\r\nfunction *pointerGenerator(board: SolverBoard){\r\n    for(let points of getAllBoxes()){\r\n        for(let cand = 1; cand <= 9; cand++){\r\n            const pointsWithCand = getPointsWithCandidates(board, points, [cand])\r\n            if(pointsWithCand.length === 1) continue // If it's only one, it's just a hidden single\r\n            if(pointsWithCand.length > 3) continue // Can't fit on a line in a box if more than 3\r\n\r\n            let pointsToRemove: Point[] = []\r\n            if(unique(pointsWithCand.map(getColNumber)).length === 1){\r\n                pointsToRemove = difference(getColumn(pointsWithCand[0].x), pointsWithCand, pointsEqual)\r\n            }else if(unique(pointsWithCand.map(getRowNumber)).length === 1){\r\n                pointsToRemove = difference(getRow(pointsWithCand[0].y), pointsWithCand, pointsEqual)\r\n            }\r\n            const effects = removeCandidateFromPoints(board, pointsToRemove, cand)\r\n            const actors = pointsWithCand.map(point => ({point, cand}))\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * If all of a certain candidate within a row or col are in the same box, the rest of the box can be eliminated\r\n */\r\nfunction *inversePointerGenerator(board: SolverBoard){\r\n    for(let points of [...getAllRows(), ...getAllCols()]){\r\n        for(let cand = 1; cand <= 9; cand++){\r\n            const pointsWithCand = getPointsWithCandidates(board, points, [cand])\r\n            if(pointsWithCand.length === 1) continue // If it's only one, it's just a hidden single\r\n            if(pointsWithCand.length > 3) continue // Can't fit in a box if it's more than 3\r\n\r\n            if(unique(pointsWithCand.map(getBoxNumber)).length === 1){\r\n                const pointsToRemove = difference(getBox(pointsWithCand[0]), pointsWithCand, pointsEqual)\r\n                const effects = removeCandidateFromPoints(board, pointsToRemove, cand)\r\n                const actors = pointsWithCand.map(point => ({point, cand}))\r\n\r\n                if(effects.length > 0){\r\n                    yield {effects, actors}\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const pointer = (board: SolverBoard) => first(pointerGenerator(board))\r\nexport const allPointers = (board: SolverBoard) => allResults(pointerGenerator(board))\r\n\r\nexport const inversePointer = (board: SolverBoard) => first(inversePointerGenerator(board))\r\nexport const allInversePointers = (board: SolverBoard) => allResults(inversePointerGenerator(board))","import { SolverBoard } from '../types'\r\nimport {\r\n    allCandidates, candidatesExcept,\r\n    getAllHousesMinusFilledPoints,\r\n    getBoardCell,\r\n    getPointsWithCandidates,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { allResults, difference, first, getCombinations, uniqueBy } from '../utils/misc'\r\nimport { removeCandidatesFromPoints } from '../utils/effects'\r\n\r\nfunction *nakedSubsetGenerator(board: SolverBoard, len: number){\r\n    for(let points of getAllHousesMinusFilledPoints(board)){\r\n        for(let candidates of getCombinations(allCandidates, len)){\r\n            const pointsInside = points.filter(p => getBoardCell(board, p).candidates.every(c => candidates.includes(c)))\r\n            if(pointsInside.length !== len) continue\r\n\r\n            const pointsOutside = difference(points, pointsInside, pointsEqual)\r\n\r\n            const effects = removeCandidatesFromPoints(board, pointsOutside, candidates)\r\n            const actors = pointsInside.flatMap(point => candidates.map(cand => ({ point, cand })))\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction *subsetGenerator(board: SolverBoard, len: number){\r\n    const minInstanceEachCand = 2 // True for pair, triple, and quad. Just hardcode it.\r\n    for(let points of getAllHousesMinusFilledPoints(board)){\r\n        for(let candidates of getCombinations(allCandidates, len)){\r\n            const subsetPointLists = candidates.map(cand => getPointsWithCandidates(board, points, [cand]))\r\n            const everyCandIsRepresented = subsetPointLists.every(points => points.length >= minInstanceEachCand && points.length <= len)\r\n            if(!everyCandIsRepresented) continue\r\n\r\n            const pointsInside = uniqueBy(subsetPointLists.flat(), pointsEqual)\r\n            if(pointsInside.length !== len) continue\r\n\r\n            const pointsOutside = difference(points, pointsInside, pointsEqual)\r\n\r\n            const effects = [\r\n                ...removeCandidatesFromPoints(board, pointsOutside, candidates),\r\n                ...removeCandidatesFromPoints(board, pointsInside, candidatesExcept(candidates))\r\n            ]\r\n            const actors = pointsInside.flatMap(point => candidates.map(cand => ({ point, cand })))\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const nakedPair = (board: SolverBoard) => first(nakedSubsetGenerator(board, 2))\r\nexport const allNakedPairs = (board: SolverBoard) => allResults(nakedSubsetGenerator(board, 2))\r\n\r\nexport const hiddenPair = (board: SolverBoard) => first(subsetGenerator(board, 2))\r\nexport const allHiddenPairs = (board: SolverBoard) => allResults(subsetGenerator(board, 2))\r\n\r\nexport const nakedTriple = (board: SolverBoard) => first(nakedSubsetGenerator(board, 3))\r\nexport const allNakedTriples = (board: SolverBoard) => allResults(nakedSubsetGenerator(board, 3))\r\n\r\nexport const hiddenTriple = (board: SolverBoard) => first(subsetGenerator(board, 3))\r\nexport const allHiddenTriples = (board: SolverBoard) => allResults(subsetGenerator(board, 3))\r\n\r\nexport const nakedQuad = (board: SolverBoard) => first(nakedSubsetGenerator(board, 4))\r\nexport const allNakedQuads = (board: SolverBoard) => allResults(nakedSubsetGenerator(board, 4))\r\n\r\nexport const hiddenQuad = (board: SolverBoard) => first(subsetGenerator(board, 4))\r\nexport const allHiddenQuads = (board: SolverBoard) => allResults(subsetGenerator(board, 4))","import { Point, SolverBoard } from '../types'\r\nimport { allResults, difference, first, getCombinations, groupBy, intersectionOfAll } from '../utils/misc'\r\nimport {\r\n    getAffectedPointsInCommon,\r\n    getAllUnfilledPoints, getColNumber,\r\n    getColumn,\r\n    getPointsWithCandidates, getRow,\r\n    getRowNumber,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\n\r\nfunction *fishGenerator(board: SolverBoard, len: number){\r\n    const getFishResult = (fishPoints: Point[], getLineNumber, getLine, cand) => {\r\n        const lines = Object.values<Point[]>(groupBy(fishPoints, getLineNumber))\r\n        if(lines.length !== len) return null\r\n\r\n        const pointsOnLines = lines.flatMap(points => getLine(getLineNumber(points[0])))\r\n        const pointsToRemove = difference(pointsOnLines, fishPoints, pointsEqual)\r\n\r\n        const effects = removeCandidateFromPoints(board, pointsToRemove, cand)\r\n        const actors = fishPoints.map(point => ({point, cand}))\r\n\r\n        if(effects.length > 0){\r\n            return {effects, actors}\r\n        }\r\n    }\r\n\r\n    const minInstancesPerHouse = 2\r\n    const allPoints = getAllUnfilledPoints(board)\r\n\r\n    for(let cand = 1; cand <= 9; cand++){\r\n        const pointsWithCand = getPointsWithCandidates(board, allPoints, [cand])\r\n\r\n        const rowsWithLen = Object.values<Point[]>(groupBy(pointsWithCand, getRowNumber))\r\n            .filter(points => points.length >= minInstancesPerHouse && points.length <= len)\r\n\r\n        for(let rows of getCombinations(rowsWithLen, len)){\r\n            const result = getFishResult(rows.flat(), getColNumber, getColumn, cand)\r\n            if(result) yield result\r\n        }\r\n\r\n        const colsWithLen = Object.values<Point[]>(groupBy(pointsWithCand, getColNumber))\r\n            .filter(points => points.length >= minInstancesPerHouse && points.length <= len)\r\n\r\n        for(let cols of getCombinations(colsWithLen, len)){\r\n            const result = getFishResult(cols.flat(), getRowNumber, getRow, cand)\r\n            if(result) yield result\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction *finnedFishGenerator(board: SolverBoard, len: number, allowSashimi: boolean){\r\n    const getFishResult = (fishPointsIncludingFins: Point[], getLineNumber, getLine, cand) => {\r\n        const possibleLines = Object.values<Point[]>(groupBy(fishPointsIncludingFins, getLineNumber))\r\n\r\n        for(let lines of getCombinations(possibleLines, len)){\r\n            if (lines.some(line => line.length === 1) && !allowSashimi) {\r\n                continue\r\n            }\r\n            const fishPoints = lines.flatMap(points => points)\r\n            const fins = difference(fishPointsIncludingFins, fishPoints, pointsEqual)\r\n            const fishLinePoints = lines.flatMap(points => getLine(getLineNumber(points[0])))\r\n            const pointsToRemoveIfRegularFish = difference(fishLinePoints, fishPoints, pointsEqual)\r\n            const pointsToRemoveIfFin = getAffectedPointsInCommon(fins)\r\n\r\n            const pointsToRemove = intersectionOfAll([pointsToRemoveIfRegularFish, pointsToRemoveIfFin], pointsEqual)\r\n\r\n            const effects = removeCandidateFromPoints(board, pointsToRemove, cand)\r\n            const actors = [\r\n                ...fishPoints.map(point => ({point, cand})),\r\n                ...fins.map(point => ({point, cand}))\r\n            ]\r\n\r\n            if(effects.length > 0){\r\n                return {effects, actors}\r\n            }\r\n        }\r\n    }\r\n\r\n    const allPoints = getAllUnfilledPoints(board)\r\n\r\n    for(let cand = 1; cand <= 9; cand++){\r\n        const pointsWithCand = getPointsWithCandidates(board, allPoints, [cand])\r\n\r\n        const possibleRows = Object.values<Point[]>(groupBy(pointsWithCand, getRowNumber))\r\n\r\n        for(let rows of getCombinations(possibleRows, len)){\r\n            const result = getFishResult(rows.flat(), getColNumber, getColumn, cand)\r\n            if(result) yield result\r\n        }\r\n\r\n        const possibleCols = Object.values<Point[]>(groupBy(pointsWithCand, getColNumber))\r\n\r\n        for(let cols of getCombinations(possibleCols, len)){\r\n            const result = getFishResult(cols.flat(), getRowNumber, getRow, cand)\r\n            if(result) yield result\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\n/**\r\n * Looks like 4 corners of a rectangle, where either the rows or cols are empty otherwise.\r\n * Two columns has the same candidate in only two rows. The rest of the rows can be eliminated\r\n * Two rows has the same candidate in only two cols. The rest of the columns can be eliminated.\r\n */\r\nexport const xWing = (board: SolverBoard) => first(fishGenerator(board, 2))\r\nexport const allXWings = (board: SolverBoard) => allResults(fishGenerator(board, 2))\r\n\r\nexport const swordfish = (board: SolverBoard) => first(fishGenerator(board, 3))\r\nexport const allSwordfish = (board: SolverBoard) => allResults(fishGenerator(board, 3))\r\n\r\nexport const jellyfish = (board: SolverBoard) => first(fishGenerator(board, 4))\r\nexport const allJellyfish = (board: SolverBoard) => allResults(fishGenerator(board, 4))\r\n\r\nexport const xWingFinned = (board: SolverBoard) => first(finnedFishGenerator(board, 2, false))\r\nexport const xWingFinnedSashimi = (board: SolverBoard) => first(finnedFishGenerator(board, 2, true))\r\nexport const swordfishFinned = (board: SolverBoard) => first(finnedFishGenerator(board, 3, false))\r\nexport const swordfishFinnedSashimi = (board: SolverBoard) => first(finnedFishGenerator(board, 3, true))\r\nexport const jellyfishFinned = (board: SolverBoard) => first(finnedFishGenerator(board, 4, false))\r\nexport const jellyfishFinnedSashimi = (board: SolverBoard) => first(finnedFishGenerator(board, 4, true))\r\n\r\n// NB: Larger fish can always be decomposed into smaller fish, so no point looking","import { SolverBoard, Point, EliminationEffect } from '../types'\r\nimport {\r\n    getAffectedPoints,\r\n    getAllRows, getAllUnfilledPoints,\r\n    getBoardCell,\r\n    getBoxNumber,\r\n    getColumn, getPointId, getPointsWithCandidates,\r\n    getPointsWithNCandidates, getRow,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { difference, groupBy, unique, uniqueBy } from '../utils/misc'\r\nimport { removeCandidatesFromPoints } from '../utils/effects'\r\n\r\nconst findNakedPairs = (board: SolverBoard, points: Point[]) => {\r\n    const pairs: {points: Point[], candidates: number[]}[] = []\r\n    const pointsWith2Cands = getPointsWithNCandidates(board, points, 2)\r\n\r\n    for(let i = 0; i < pointsWith2Cands.length; i++){\r\n        for(let j = i+1; j < pointsWith2Cands.length; j++){\r\n            const pointsInside = [pointsWith2Cands[i], pointsWith2Cands[j]]\r\n            const allCandidates = unique(pointsInside.flatMap(p => getBoardCell(board, p).candidates)) as number[]\r\n            if(allCandidates.length !== 2) continue\r\n\r\n            pairs.push({points: pointsInside, candidates: allCandidates})\r\n        }\r\n    }\r\n    return pairs\r\n}\r\n\r\n/**\r\n * TODO: This can be written better. No need to look for all those pairs\r\n *\r\n * pairs of numbers in a rectangle shape cannot only contain those pairs.\r\n * Otherwise the sudoku can't be unique.\r\n * Only applies if there's only two boxes in play.\r\n *\r\n * Type 1: 3 corners with two possible candidates. We can eliminate those candidates from the fourth corner\r\n * (any value that would \"resolve\" the uniqueness would either make the 3 corners have 0 candidates, or itself eliminate the 4 corner candidates like we would otherwise)\r\n * TODO: Type 2: 1 extra candidate in two cells that are not diagonals. This will then create a pointer, since the candidate must be in either of those cells.\r\n * TODO: Type 3: Same as type 2, but more candidates. Treat the cells of the rectangle as one virtual cell, and look for naked pair/triple/quad.\r\n * TODO: Type 4: Same as type 3, but this time check if one of the rectangle candidates are only in the rectangle cells in that box/column/row. If so, delete the other rectangle candidate.\r\n * TODO: Type 5: Same as type 2, but the extra candidate is on a diagonal. The candidate must be in one of these. See if there are cells that sees both of these, and eliminate the cand from those.\r\n * TODO: Type 6: See if one of the rectangle candidates form an x-wing. If so, it must be placed on two points diagonally. If this removes all other candidates from the rectangle, it is invalid, and so can be eliminated.\r\n * TODO: Hidden, avoidable 1/2, missing candidates. These seem a bit too exotic tbh.\r\n */\r\nexport const uniqueRectangle1 = (board: SolverBoard) => {\r\n    for(let points of getAllRows()){\r\n        const pairs = findNakedPairs(board, points)\r\n        for(let pair of pairs){\r\n            const colPairs = [\r\n                ...findNakedPairs(board, getColumn(pair.points[0].x)),\r\n                ...findNakedPairs(board, getColumn(pair.points[1].x))\r\n            ]\r\n\r\n            const matchingPairs = colPairs\r\n                .filter(colPair => unique([...colPair.candidates, ...pair.candidates]).length === 2) // Has the same two candidates\r\n                .filter(colPair => difference(pair.points, colPair.points, pointsEqual).length === 1) // Shares one point\r\n                .filter(colPair => unique([...colPair.points, ...pair.points].map(getBoxNumber)).length === 2) // In exactly two boxes\r\n\r\n            for(let colPair of matchingPairs){\r\n                const corners = uniqueBy([...colPair.points, ...pair.points], pointsEqual)\r\n                const x = Object.values<any>(groupBy(corners, p => p.x)).filter(xs => xs.length === 1).map(xs => xs[0])[0].x\r\n                const y = Object.values<any>(groupBy(corners, p => p.y)).filter(ys => ys.length === 1).map(ys => ys[0])[0].y\r\n                const missingCorner = {\r\n                    x, y, id: getPointId(x, y)\r\n                }\r\n                const candidates = pair.candidates\r\n                const effects = removeCandidatesFromPoints(board, [missingCorner], candidates)\r\n                const actors = corners.flatMap(point => candidates.map(cand => ({ point, cand })))\r\n\r\n                if(effects.length > 0){\r\n                    return {effects, actors}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport const hiddenRectangle = (board: SolverBoard) => {\r\n    const unfilledPoints = getAllUnfilledPoints(board)\r\n    const biValuePoints = getPointsWithNCandidates(board, unfilledPoints, 2)\r\n\r\n    for(let startingCorner of biValuePoints) {\r\n        const cands = getBoardCell(board, startingCorner).candidates\r\n\r\n        const row = getPointsWithCandidates(board, getRow(startingCorner.y), cands).filter(p => !pointsEqual(p, startingCorner))\r\n        const col = getPointsWithCandidates(board, getColumn(startingCorner.x), cands).filter(p => !pointsEqual(p, startingCorner))\r\n\r\n        for(let rowCorner of row){\r\n            for(let colCorner of col){\r\n                const x = rowCorner.x\r\n                const y = colCorner.y\r\n                const oppositeCorner: Point = {x, y, id: getPointId(x, y)}\r\n                const oppositeCell = getBoardCell(board, oppositeCorner)\r\n                const hiddenRect = [startingCorner, rowCorner, colCorner, oppositeCorner]\r\n                const nBoxes = unique(hiddenRect.map(getBoxNumber)).length\r\n                if (nBoxes !== 2){\r\n                    continue\r\n                }\r\n\r\n                if (cands.every(cand => oppositeCell.candidates.includes(cand))) {\r\n                    for (let cand of cands) {\r\n                        const affected = getAffectedPoints(oppositeCorner)\r\n                        const everyPointWithCandIsInRect = getPointsWithCandidates(board, affected, [cand])\r\n                            .every(p => hiddenRect.some(hp => pointsEqual(p, hp)))\r\n                        if (everyPointWithCandIsInRect) {\r\n                            const effects: EliminationEffect[] = [{\r\n                                type: 'elimination',\r\n                                point: oppositeCorner,\r\n                                numbers: cands.filter(c => c !== cand)\r\n                            }]\r\n                            const actors = hiddenRect.flatMap(point => cands.map(cand => ({ point, cand })))\r\n                            return { effects, actors}\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}","import { SolverBoard, Point } from '../types'\r\nimport { allResults, difference, first, getCombinations, groupBy } from '../utils/misc'\r\nimport {\r\n    getAffectedPointsInCommon,\r\n    getAllUnfilledPoints, getColNumber,\r\n    getPointsWithCandidates, getRowNumber,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\n\r\n/**\r\n * Basically an x-wing where one candidate is not aligned.\r\n * The line (row or col) where the points are aligned force the candidate to be placed in one of the other two points.\r\n * All other cells that sees these two candidates can be eliminated.\r\n */\r\nfunction *skyscraperGenerator(board: SolverBoard){\r\n    const getSkyscraperResult = (skyscraperPoints: Point[], getLineNumber, cand: number) => {\r\n        const pointsOnLine = Object.values<Point[]>(groupBy(skyscraperPoints, getLineNumber)).filter(points => points.length === 2)[0]\r\n        if(!pointsOnLine) return null\r\n\r\n        const pointsToCheck = difference(skyscraperPoints, pointsOnLine, pointsEqual)\r\n        const affectedInCommon = getAffectedPointsInCommon(pointsToCheck)\r\n        const pointsToRemove = difference(affectedInCommon, skyscraperPoints, pointsEqual)\r\n\r\n        const effects = removeCandidateFromPoints(board, pointsToRemove, cand)\r\n        const actors = skyscraperPoints.map(point => ({point, cand}))\r\n\r\n        if(effects.length > 0){\r\n            return {effects, actors}\r\n        }\r\n        return null\r\n    }\r\n\r\n    const allPoints = getAllUnfilledPoints(board)\r\n\r\n    for(let cand = 1; cand <= 9; cand++){\r\n        const pointsWithCand = getPointsWithCandidates(board, allPoints, [cand])\r\n\r\n        const rowsWithTwo = Object.values<Point[]>(groupBy(pointsWithCand, getRowNumber)).filter(points => points.length === 2)\r\n\r\n        for(let rows of getCombinations(rowsWithTwo, 2)){\r\n            const result = getSkyscraperResult(rows.flat(), getColNumber, cand)\r\n            if(result) yield result\r\n        }\r\n\r\n        const colsWithTwo = Object.values<Point[]>(groupBy(pointsWithCand, getColNumber)).filter(points => points.length === 2)\r\n\r\n        for(let cols of getCombinations(colsWithTwo, 2)){\r\n            const result = getSkyscraperResult(cols.flat(), getRowNumber, cand)\r\n            if(result) yield result\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const skyscraper = (board: SolverBoard) => first(skyscraperGenerator(board))\r\nexport const allSkyscrapers = (board: SolverBoard) => allResults(skyscraperGenerator(board))","/**\r\n * Empty rectangles can be pretty simple:\r\n *\r\n * Pick one candidate\r\n * If you have a box with the candidate in only one row and one column, the cells not on that row and column is the \"empty rectangle\".\r\n * As usual, the weird naming in sudoku makes it harder to understand, so forget about the empty rectangle, and focus on the row and column instead.\r\n *\r\n * It comes down to this: If either the column or the row is eliminated, what remains is a pointer.\r\n * We can abuse this by looking for conjugate pairs (2 candidates in a house) where one cell of the pair sees the row or column in the box.\r\n * If the pair candidate is in this cell, we have a pointer\r\n * If the pair candidate is in the other cell, we can do basic eliminations\r\n * If the pointer and the basic elimination sees the same cell, the candidate can be removed from that cell\r\n *\r\n * NB: There is something called a dual rectangle where you can eliminate two points, but we can just run the algo twice and get the same result.\r\n */\r\nimport { SolverBoard, Point } from '../types'\r\nimport {\r\n    allCandidates,\r\n    getAllBoxes,\r\n    getBoxNumber, getColsOutsideBox, getColumn, getPointId,\r\n    getPointsWithCandidates,\r\n    getRowsOutsideBox,\r\n    pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\nimport { allResults, difference, first, unique } from '../utils/misc'\r\n\r\nfunction *emptyRectangleGenerator(board: SolverBoard){\r\n    const getResult = (pairHouse: Point[], erPoints: Point[], pointerX, pointerY, cand) => {\r\n        const pair = getPointsWithCandidates(board, pairHouse, [cand])\r\n        if(pair.length !== 2) return null\r\n\r\n        let pointToRemove: Point\r\n        if(pair.some(point => point.x === pointerX)){\r\n            const otherPoint = pair.find(point => point.x !== pointerX)\r\n            if(!otherPoint) return null\r\n            pointToRemove = {x: otherPoint.x, y: pointerY, id: getPointId(otherPoint.x, pointerY)}\r\n        }else if(pair.some(point => point.y === pointerY)){\r\n            const otherPoint = pair.find(point => point.y !== pointerY)\r\n            if(!otherPoint) return null\r\n            pointToRemove = {x: pointerX, y: otherPoint.y, id: getPointId(pointerX, otherPoint.y)}\r\n        }else{\r\n            return null\r\n        }\r\n\r\n        // If both points are directly below/above (left/right) the box, it will try to eliminate a point inside the box, which is not valid\r\n        if(erPoints.some(p => pointsEqual(p, pointToRemove))) return null\r\n\r\n        const effects = removeCandidateFromPoints(board, [pointToRemove], cand)\r\n        const actors = [...erPoints, ...pair].map(point => ({point, cand}))\r\n        if(effects.length > 0){\r\n            return {effects, actors}\r\n        }\r\n        return null\r\n    }\r\n\r\n    for(let box of getAllBoxes()){\r\n        for(let cand of allCandidates){\r\n            const erPoints = getPointsWithCandidates(board, box, [cand])\r\n            const boxNumber = getBoxNumber(box[0])\r\n            const pairHouses = [...getRowsOutsideBox(boxNumber), ...getColsOutsideBox(boxNumber)]\r\n\r\n            if(erPoints.length === 2 && erPoints[0].x !== erPoints[1].x && erPoints[0].y !== erPoints[1].y){\r\n                // Only two points, diagonally. Still an ER, but with no clearly defined row and col. This means we have to try both.\r\n\r\n                for(let pairHouse of pairHouses){\r\n                    let result = getResult(pairHouse, erPoints, erPoints[0].x, erPoints[1].y, cand)\r\n                    if(result) yield result\r\n\r\n                    result = getResult(pairHouse, erPoints, erPoints[1].x, erPoints[0].y, cand)\r\n                    if(result) yield result\r\n                }\r\n            }else{\r\n                const colNumbers = unique(erPoints.map(p => p.x))\r\n                let pointerLines: any = null\r\n                for(let colNumber of colNumbers){\r\n                    const wholeColumn = getColumn(colNumber)\r\n                    const restPoints = difference(erPoints, wholeColumn, pointsEqual)\r\n                    if(restPoints.length > 0 && restPoints.every(p => p.y === restPoints[0].y)){\r\n                        pointerLines = {\r\n                            x: colNumber,\r\n                            y: restPoints[0].y\r\n                        }\r\n                    }\r\n                }\r\n                if(pointerLines !== null){\r\n                    for(let pairHouse of pairHouses){\r\n                        const result = getResult(pairHouse, erPoints, pointerLines.x, pointerLines.y, cand)\r\n                        if(result) yield result\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const emptyRectangle = (board: SolverBoard) => first(emptyRectangleGenerator(board))\r\nexport const allEmptyRectangles = (board: SolverBoard) => allResults(emptyRectangleGenerator(board))","import { SolverBoard } from '../types'\r\nimport {\r\n    allCandidates,\r\n    getAffectedPoints, getAffectedPointsInCommon, getAllHousesMinusFilledPoints,\r\n    getAllUnfilledPoints,\r\n    getBoardCell, getPointsWithCandidates,\r\n    getPointsWithNCandidates, pointsWhere\r\n} from '../utils/sudokuUtils'\r\nimport { allResults, arraysEqual, difference, first } from '../utils/misc'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\n\r\nfunction *xyWingGenerator(board: SolverBoard){\r\n    const biValuePoints = getPointsWithNCandidates(board, getAllUnfilledPoints(board), 2)\r\n\r\n    for(let pivot of biValuePoints){\r\n        const affectedBiValuesPoints = getPointsWithNCandidates(board, getAffectedPoints(pivot), 2)\r\n        const xy = getBoardCell(board, pivot).candidates\r\n        const [x, y] = xy\r\n        const zValues = difference(allCandidates, xy, (a, b) => a === b)\r\n        for(let z of zValues){\r\n            const pincer1 = getPointsWithCandidates(board, affectedBiValuesPoints, [z, x])[0]\r\n            if(!pincer1) continue\r\n\r\n            const pincer2 = getPointsWithCandidates(board, affectedBiValuesPoints, [z, y])[0]\r\n            if(!pincer2) continue\r\n\r\n            const pointsToRemove = getAffectedPointsInCommon([pincer1, pincer2])\r\n            const effects = removeCandidateFromPoints(board, pointsToRemove, z)\r\n            const actors = [{point: pivot}, {point: pincer1}, {point: pincer2}]\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nfunction *xyzWingGenerator(board: SolverBoard){\r\n    const triValuePoints = getPointsWithNCandidates(board, getAllUnfilledPoints(board), 3)\r\n\r\n    for(let pivot of triValuePoints){\r\n        const affectedBiValuesPoints = getPointsWithNCandidates(board, getAffectedPoints(pivot), 2)\r\n        const pivotCands = getBoardCell(board, pivot).candidates\r\n        for(let z of pivotCands){\r\n            const xy = difference(pivotCands, [z], (a, b) => a === b)\r\n            const [x, y] = xy\r\n\r\n            const pincer1 = getPointsWithCandidates(board, affectedBiValuesPoints, [z, x])[0]\r\n            if(!pincer1) continue\r\n\r\n            const pincer2 = getPointsWithCandidates(board, affectedBiValuesPoints, [z, y])[0]\r\n            if(!pincer2) continue\r\n\r\n            const pointsToRemove = getAffectedPointsInCommon([pivot, pincer1, pincer2])\r\n            const effects = removeCandidateFromPoints(board, pointsToRemove, z)\r\n            const actors = [{point: pivot}, {point: pincer1}, {point: pincer2}]\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nconst candidatesEqual = (cands1, cands2) => arraysEqual(cands1, cands2, (a, b) => a === b)\r\n\r\nfunction *wWingGenerator(board: SolverBoard){\r\n    for(let x of allCandidates){\r\n        for(let house of getAllHousesMinusFilledPoints(board)){\r\n            const pointsWithX = getPointsWithCandidates(board, house, [x])\r\n            if(pointsWithX.length === 2){\r\n                const affected1 = getAffectedPoints(pointsWithX[0])\r\n                const affected2 = getAffectedPoints(pointsWithX[1])\r\n                for(let w of allCandidates){\r\n                    const wx = [w, x]\r\n                    const wxPoints1 = pointsWhere(board, affected1, cell => candidatesEqual(cell.candidates, wx))\r\n                    const wxPoints2 = pointsWhere(board, affected2, cell => candidatesEqual(cell.candidates, wx))\r\n                    for(let i = 0; i < wxPoints1.length; i++){\r\n                        for(let j = 0; j < wxPoints2.length; j++){\r\n                            const common = getAffectedPointsInCommon([wxPoints1[i], wxPoints2[j]])\r\n                            const effects = removeCandidateFromPoints(board, common, w)\r\n                            const actors = [\r\n                                ...pointsWithX.map(point => ({ point, cand: x })),\r\n                                ...wx.map(cand => ({ point: wxPoints1[i], cand })),\r\n                                ...wx.map(cand => ({ point: wxPoints2[j], cand }))\r\n                            ]\r\n                            if(effects.length > 0){\r\n                                yield {effects, actors}\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nexport const xyWing = (board: SolverBoard) => first(xyWingGenerator(board))\r\nexport const allXyWings = (board: SolverBoard) => allResults(xyWingGenerator(board))\r\n\r\nexport const xyzWing = (board: SolverBoard) => first(xyzWingGenerator(board))\r\nexport const allXyzWings = (board: SolverBoard) => allResults(xyzWingGenerator(board))\r\n\r\nexport const wWing = (board: SolverBoard) => first(wWingGenerator(board))\r\nexport const allWWings = (board: SolverBoard) => allResults(wWingGenerator(board))","import { SetValueEffect, SolverBoard } from '../types'\r\nimport { canPutDigit, cloneBoard, getAllUnfilledPoints, getBoardCell, getPointId } from '../utils/sudokuUtils'\r\nimport { allResults, first } from '../utils/misc'\r\n\r\nfunction *generateBruteForceDigits(board: SolverBoard){\r\n    const clonedBoard = cloneBoard(board)\r\n    solve(clonedBoard)\r\n    const unfilledPoints = getAllUnfilledPoints(board)\r\n    for(let point of unfilledPoints){\r\n        yield {\r\n            effects: [{type: 'value', point, number: getBoardCell(clonedBoard, point).value} as SetValueEffect],\r\n            actors: [{point}]\r\n        }\r\n    }\r\n}\r\n\r\nconst solve = (board: SolverBoard, x = 0, y = 0) => {\r\n    if(x === 9){\r\n        x = 0\r\n        y++\r\n        if(y === 9){\r\n            return board // Got to the end of the board, solution found\r\n        }\r\n    }\r\n    if(board[y][x].value !== null){\r\n        return solve(board, x+1, y)\r\n    }\r\n\r\n    for(let n = 1; n <= 9; n++){\r\n        if(canPutDigit(board, {x, y, id: getPointId(x, y)}, n)){\r\n            board[y][x].value = n\r\n            const solution = solve(board, x+1,y)\r\n            if(solution){\r\n                return solution\r\n            }\r\n        }\r\n    }\r\n\r\n    board[y][x].value = null\r\n    return null\r\n}\r\n\r\nexport const bruteForce = (board: SolverBoard) => first(generateBruteForceDigits(board))\r\nexport const allBruteForceDigits = (board: SolverBoard) => allResults(generateBruteForceDigits(board))","import {\r\n    EliminationEffect, GroupEliminationEffect,\r\n    GroupSetValueEffect,\r\n    Point,\r\n    SetValueEffect,\r\n    SolverBoard\r\n} from '../types'\r\nimport {\r\n    allCandidates,\r\n    cloneBoard,\r\n    getAllHousesMinusFilledPoints,\r\n    getBoardCell,\r\n    getBox,\r\n    getBoxGroups,\r\n    getBoxNumber,\r\n    getColNumber,\r\n    getColumn,\r\n    getPointsWithCandidates,\r\n    getRow,\r\n    getRowNumber, pointsEqual\r\n} from '../utils/sudokuUtils'\r\nimport {\r\n    effectsEqual,\r\n    removeCandidateFromAffectedPoints,\r\n    removeCandidatesFromPoints,\r\n    uniqueEffects\r\n} from '../utils/effects'\r\nimport { difference, intersectionOfAll, unique, uniqueBy } from '../utils/misc'\r\n\r\nexport const getPointKey = (point: Point) => point.id\r\nexport const getGroupId = (group: Point[]) => group.map(p => p.id).join('-')\r\n\r\nexport type SingleNode = {\r\n    type: 'single'\r\n    point: Point\r\n    cand: number\r\n}\r\nexport type GroupNode = {\r\n    type: 'group'\r\n    points: Point[]\r\n    groupId: string\r\n    cand: number\r\n}\r\nexport type LinkNode = SingleNode | GroupNode\r\n\r\nexport type Link<P extends LinkNode = LinkNode, N extends LinkNode = LinkNode> = {\r\n    type: 'weak' | 'strong'\r\n    prev: P\r\n    next: N\r\n}\r\nexport type SingleLink = Link<SingleNode, SingleNode>\r\n\r\nexport type Table<T extends Link = Link> = {\r\n    [key: string]: {\r\n        points: Point[]\r\n        links: T[]\r\n    }\r\n}\r\n\r\nexport type SingleTable = Table<SingleLink>\r\n\r\nconst getLinks = (\r\n    node: SingleNode | GroupNode,\r\n    effectsIfTrue: EliminationEffect[],\r\n    effectsIfFalse: SetValueEffect[],\r\n    groupEffectsIfTrue: GroupEliminationEffect[],\r\n    groupEffectsIfFalse: GroupSetValueEffect[]\r\n): Link[] => {\r\n    const prev = node\r\n    return [\r\n        ...effectsIfFalse.map((eff) => ({\r\n            type: 'strong' as const,\r\n            prev,\r\n            next: {\r\n                type: 'single' as const,\r\n                point: eff.point,\r\n                cand: eff.number\r\n            }\r\n        })),\r\n        ...effectsIfTrue.flatMap((eff) => eff.numbers.map(cand => ({\r\n            type: 'weak' as const,\r\n            prev,\r\n            next: {\r\n                type: 'single' as const,\r\n                point: eff.point,\r\n                cand\r\n            }\r\n        }))),\r\n        ...groupEffectsIfFalse.map((eff) => ({\r\n            type: 'strong' as const,\r\n            prev,\r\n            next: {\r\n                type: 'group' as const,\r\n                points: eff.group,\r\n                groupId: eff.groupId,\r\n                cand: eff.number\r\n            }\r\n        })),\r\n        ...groupEffectsIfTrue.map((eff) => ({\r\n            type: 'weak' as const,\r\n            prev,\r\n            next: {\r\n                type: 'group' as const,\r\n                points: eff.group,\r\n                groupId: eff.groupId,\r\n                cand: eff.number\r\n            }\r\n        }))\r\n    ]\r\n}\r\n\r\nconst getNakedSingle = (board: SolverBoard, point: Point): SetValueEffect[] => {\r\n    const cell = getBoardCell(board, point)\r\n    if(cell.candidates.length === 1) {\r\n        return [{type: 'value', point, number: cell.candidates[0]}]\r\n    }\r\n    return []\r\n}\r\nconst getHiddenSingles = (board: SolverBoard): SetValueEffect[] => {\r\n    const effects: SetValueEffect[] = []\r\n    for(let house of getAllHousesMinusFilledPoints(board)){\r\n        for(let cand = 1; cand <= 9; cand++){\r\n            const pointsWithCand = house.filter(p => getBoardCell(board, p).candidates.some(c => c === cand))\r\n            if(pointsWithCand.length === 1){\r\n                const point = pointsWithCand[0]\r\n                effects.push({type: 'value', point, number: cand} as const)\r\n            }\r\n        }\r\n    }\r\n    return effects\r\n}\r\n\r\nconst getSingleFalseSingleEffects = (board: SolverBoard, point: Point, cand: number): SetValueEffect[] => {\r\n    const cell = getBoardCell(board, point)\r\n    const cands = [...cell.candidates]\r\n    cell.candidates = cell.candidates.filter(c => c !== cand)\r\n    const effects = uniqueEffects([\r\n        ...getNakedSingle(board, point),\r\n        ...getHiddenSingles(board)\r\n    ])\r\n    cell.candidates = cands\r\n    return effects\r\n}\r\nconst getSingleFalseGroupEffects = (board: SolverBoard, point: Point, cand: number): GroupSetValueEffect[] => {\r\n    return getGroupFalseGroupEffects(board, [point], cand)\r\n}\r\n\r\nconst getSingleTrueSingleEffects = (board: SolverBoard, point: Point, cand: number): EliminationEffect[] => {\r\n    const cell = getBoardCell(board, point)\r\n    return [\r\n        ...removeCandidatesFromPoints(board, [point], cell.candidates.filter(c => c !== cand)),\r\n        ...removeCandidateFromAffectedPoints(board, point, cand) as EliminationEffect[]\r\n    ]\r\n}\r\nconst getSingleTrueGroupEffects = (board: SolverBoard, allGroups: Point[][], point: Point, singleTrueSingleEffects: EliminationEffect[]): GroupEliminationEffect[] => {\r\n    return getGroupTrueGroupEffects(board, allGroups, [point], singleTrueSingleEffects)\r\n}\r\n\r\n// If group is false, what single point effects are there?\r\nconst getGroupFalseSingleEffects = (board: SolverBoard, points: Point[], cand: number): SetValueEffect[] => {\r\n    board = cloneBoard(board)\r\n    for(let point of points){\r\n        const cell = getBoardCell(board, point)\r\n        cell.candidates = cell.candidates.filter(c => c !== cand)\r\n    }\r\n    return uniqueEffects([\r\n        ...points.flatMap(point => getNakedSingle(board, point)),\r\n        ...getHiddenSingles(board)\r\n    ])\r\n}\r\n\r\n// If group is false, which group effects are there?\r\nconst getGroupFalseGroupEffects = (board: SolverBoard, falseGroup: Point[], cand: number): GroupSetValueEffect[] => {\r\n    const isColumn = unique(falseGroup.map(getColNumber)).length === 1\r\n    const isRow = unique(falseGroup.map(getRowNumber)).length === 1\r\n\r\n    const housesToCheck = [\r\n        getBox(falseGroup[0])\r\n    ]\r\n    // We allow single points as input \"groups\" to this function, so check both row/col\r\n    if (isColumn) {\r\n        housesToCheck.push(getColumn(falseGroup[0].x))\r\n    }\r\n    if (isRow) {\r\n        housesToCheck.push(getRow(falseGroup[0].y))\r\n    }\r\n\r\n    const effects: GroupSetValueEffect[] = []\r\n    for(let house of housesToCheck){\r\n        const trueGroup = difference(getPointsWithCandidates(board, house, [cand]), falseGroup, pointsEqual)\r\n        if (trueGroup.length >= 2) {\r\n            const sameBox = unique(trueGroup.map(getBoxNumber)).length === 1\r\n            const sameCol = unique(trueGroup.map(getColNumber)).length === 1\r\n            const sameRow = unique(trueGroup.map(getRowNumber)).length === 1\r\n\r\n            if(sameBox && (sameCol || sameRow)){\r\n                effects.push({\r\n                    type: 'group-value' as const,\r\n                    group: trueGroup,\r\n                    groupId: getGroupId(trueGroup),\r\n                    number: cand\r\n                })\r\n            }\r\n        }\r\n    }\r\n    return effects\r\n}\r\n\r\n// If group is true, i.e. one of the points is true, what single point effects are there?\r\nconst getGroupTrueSingleEffects = (board: SolverBoard, points: Point[], cand: number): EliminationEffect[] => {\r\n    return intersectionOfAll(points.map(point => getSingleTrueSingleEffects(board, point, cand)), effectsEqual)\r\n}\r\n\r\n// If group is true, what group effects are there?\r\nconst getGroupTrueGroupEffects = (board: SolverBoard, allGroups: Point[][], trueGroup: Point[], groupTrueSingleEffects: EliminationEffect[]): GroupEliminationEffect[] => {\r\n    const groupEffects: GroupEliminationEffect[] = []\r\n    for(let group of allGroups){\r\n        for(let cand of allCandidates){\r\n            const falseGroup = difference(getPointsWithCandidates(board, group, [cand]), trueGroup, pointsEqual)\r\n            if(falseGroup.length >= 2){\r\n                const eliminatesWholeGroup = falseGroup.every(p => groupTrueSingleEffects.some(eff => p.id === eff.point.id && eff.numbers.includes(cand)))\r\n                if(eliminatesWholeGroup){\r\n                    groupEffects.push({\r\n                        type: 'group-elimination',\r\n                        group: falseGroup,\r\n                        groupId: getGroupId(falseGroup),\r\n                        number: cand\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return groupEffects\r\n}\r\n\r\n/**\r\n * The table concept I glanced from hodoku. Called trebors tables or something like that.\r\n * The idea is to record what effects occur when a candidate is either set or not set. Only direct effects are considered.\r\n * Direct in this case is hidden/naked singles and just basic eliminations.\r\n * When a candidate is set, we can use it to make weak links towards all its effected cells. Effects are basic eliminations.\r\n * When a candidate is not set, we can use it to make strong links towards all its effected cells. Effects are naked/hidden singles here.\r\n */\r\nexport const createTable = (board: SolverBoard, points: Point[], cands: number[], withGroups: boolean = false) => {\r\n    // Ensure the cells with the fewest candidates are stored first.\r\n    // These are the most likely starting cells that a human would choose.\r\n    points = points.sort((a, b) => {\r\n        return getBoardCell(board, a).candidates.length - getBoardCell(board, b).candidates.length\r\n    })\r\n\r\n    let groupsTable: Table = {}\r\n    if (withGroups) {\r\n        groupsTable = createGroupTable(board)\r\n    }\r\n    const allGroups = uniqueBy(Object.values(groupsTable).map(x => x.points), (a, b) => getGroupId(a) === getGroupId(b))\r\n\r\n    const table: Table = {}\r\n    for(let point of points){\r\n        for(let cand of cands){\r\n            const cell = getBoardCell(board, point)\r\n            if(!cell.candidates.includes(cand)){\r\n                continue\r\n            }\r\n\r\n            const effectsIfTrue = getSingleTrueSingleEffects(board, point, cand).filter(eff => points.some(p => pointsEqual(p, eff.point)))\r\n            const effectsIfFalse = getSingleFalseSingleEffects(board, point, cand).filter(eff => points.some(p => pointsEqual(p, eff.point)))\r\n\r\n            let groupEffectsIfTrue: GroupEliminationEffect[] = []\r\n            let groupEffectsIfFalse: GroupSetValueEffect[] = []\r\n            if(withGroups){\r\n                groupEffectsIfTrue = getSingleTrueGroupEffects(board, allGroups, point, effectsIfTrue)\r\n                groupEffectsIfFalse = getSingleFalseGroupEffects(board, point, cand)\r\n            }\r\n\r\n            if(effectsIfTrue.length > 0 || effectsIfFalse.length > 0){\r\n                const node: SingleNode = { type: 'single', point, cand }\r\n                const link = getLinks(node, effectsIfTrue, effectsIfFalse, groupEffectsIfTrue, groupEffectsIfFalse)\r\n                table[getPointKey(point)] = table[getPointKey(point)] ?? { points: [point], links: [] }\r\n                table[getPointKey(point)].links.push(...link)\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        ...table,\r\n        ...groupsTable\r\n    }\r\n}\r\n\r\nexport const createGroupTable = (board: SolverBoard) => {\r\n    board = cloneBoard(board)\r\n    const table: Table = {}\r\n\r\n    const groups = getBoxGroups()\r\n        .flatMap(group => {\r\n            return [\r\n                group,\r\n                [group[0], group[1]],\r\n                [group[0], group[2]],\r\n                [group[1], group[2]]\r\n            ]\r\n        })\r\n    for(let group of groups){\r\n        for(let cand of allCandidates){\r\n            const points = getPointsWithCandidates(board, group, [cand])\r\n            if(points.length >= 2){\r\n                const groupId = getGroupId(points)\r\n                const effectsIfTrue = getGroupTrueSingleEffects(board, points, cand)\r\n                const effectsIfFalse = getGroupFalseSingleEffects(board, points, cand)\r\n                const groupEffectsIfTrue = getGroupTrueGroupEffects(board, groups, points, effectsIfTrue)\r\n                const groupEffectsIfFalse = getGroupFalseGroupEffects(board, points, cand)\r\n                const hasEffects = effectsIfTrue.length > 0 || effectsIfFalse.length > 0 || groupEffectsIfTrue.length > 0 || groupEffectsIfFalse.length > 0\r\n\r\n                if(hasEffects){\r\n                    const node: GroupNode = { type: 'group', groupId, points, cand }\r\n                    const links = getLinks(node, effectsIfTrue, effectsIfFalse, groupEffectsIfTrue, groupEffectsIfFalse)\r\n                    table[groupId] = table[groupId] ?? { points, links: [] }\r\n                    table[groupId].links.push(...links)\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return table\r\n}\r\n\r\nexport const getAllLinks = (table: Table, node: LinkNode) => {\r\n    const item = table[node.type === 'single' ? getPointKey(node.point) : node.groupId]\r\n    return item ? item.links : []\r\n}","import {\r\n    Actor,\r\n    Effect,\r\n    Point,\r\n    SolverBoard,\r\n    TechniqueResult,\r\n} from '../types'\r\nimport {\r\n    removeCandidateFromPoints,\r\n    removeCandidatesFromPoints\r\n} from '../utils/effects'\r\nimport { arraysEqual, difference, unique } from '../utils/misc'\r\nimport {\r\n    allCandidates,\r\n    candidatesExcept,\r\n    getAffectedPointsInCommon,\r\n    getAllPoints,\r\n    getAllUnfilledPoints,\r\n    getBoardCell,\r\n    getBox,\r\n    getBoxNumber,\r\n    getColNumber,\r\n    getColumn,\r\n    getPointsWithNCandidates,\r\n    getRow,\r\n    getRowNumber,\r\n    pointsEqual,\r\n    pointsSeeEachOther,\r\n} from '../utils/sudokuUtils'\r\nimport {\r\n    createTable,\r\n    getAllLinks,\r\n    Link,\r\n    LinkNode,\r\n    SingleLink, SingleNode,\r\n    Table\r\n} from './chainGraph'\r\n\r\nconst getNodePoints = (node: LinkNode) => node.type === 'single' ? [node.point] : node.points\r\n\r\nconst linkIsInternalWithinPoint = (link: Link) => {\r\n    if (link.prev.type === 'single' && link.next.type === 'single') {\r\n        return link.prev.point.id === link.next.point.id\r\n    }\r\n    return false\r\n}\r\n\r\ntype QueueItem = {\r\n    seen: Set<number | string>\r\n    chain: Link[]\r\n}\r\n\r\nconst getSeenKeys = (node: LinkNode) => node.type === 'single' ? [node.point.id] : node.points.map(p => p.id)\r\n\r\nconst iterateChainsInTable = (table: Table, keepLink, check, maxDepth: number = 13) => {\r\n    const isValidNextLink = (chain: Link[], seen: Set<string | number>, link: Link) => {\r\n        const first = chain[0] as Link<SingleNode>\r\n        const last = chain[chain.length - 1]\r\n\r\n        if(link.prev.cand !== last.next.cand) return false\r\n\r\n        const requiredLinkType = last.type === 'strong' ? 'weak' : 'strong'\r\n        if(link.type !== requiredLinkType) return false\r\n\r\n        if(!keepLink(link)) return false\r\n\r\n        const lastWasInternal = linkIsInternalWithinPoint(last)\r\n        const nextIsInternal = linkIsInternalWithinPoint(link)\r\n\r\n        if(lastWasInternal && nextIsInternal) return false // Prevent eternal loop\r\n\r\n        const isLoop = link.next.type !== 'group' && first.prev.point.id === link.next.point.id\r\n\r\n        // Can't be lasso if loop or internal link\r\n        if(isLoop) return true\r\n        if(nextIsInternal) return true\r\n\r\n        // NB: We don't check for internal links between groups or single<->group\r\n        // That means that we'll not all those as lassos, and won't use the link\r\n\r\n        const isLasso = getSeenKeys(link.next).some(key => seen.has(key))\r\n        return !isLasso\r\n    }\r\n\r\n    let queue: QueueItem[] = Object.values(table)\r\n        .flatMap(x => x.links\r\n            .filter(link => keepLink(link) && link.prev.type === 'single')\r\n            .map(link => ({ chain: [link], seen: new Set(getSeenKeys(link.prev)) }))\r\n        )\r\n\r\n    let i = 0\r\n    while(i < queue.length){\r\n        const queueItem = queue[i++] // Don't shift the queue. Turns out to be super slow when it becomes large.\r\n        const { chain } = queueItem\r\n        const firstLink = chain[0] as Link<SingleNode>\r\n        const lastLink = chain[chain.length - 1]\r\n\r\n        let isLoop = false\r\n        if(lastLink.next.type !== 'group' && chain.length > 1){\r\n            isLoop = firstLink.prev.point.id === lastLink.next.point.id\r\n            if(check(chain, isLoop)){\r\n                return true\r\n            }\r\n        }\r\n        if(isLoop){\r\n            continue\r\n        }\r\n\r\n        if(queueItem.chain.length >= maxDepth){\r\n            continue\r\n        }\r\n\r\n        const seen = new Set([...queueItem.seen, ...getSeenKeys(lastLink.next)])\r\n        const nextLinks = getAllLinks(table, lastLink.next).filter(link => isValidNextLink(chain, seen, link))\r\n        for(let nextLink of nextLinks){\r\n            queue.push({ chain: [...chain, nextLink], seen })\r\n        }\r\n\r\n        // Clear some memory every once in a while\r\n        if(queue.length > 1000000){\r\n            queue = queue.slice(i)\r\n            i = 0\r\n        }\r\n    }\r\n\r\n    return false\r\n}\r\n\r\nconst chainToActors = (chain: Link[]): Actor[] => {\r\n    const first = chain[0].prev.type === 'single'\r\n        ? [{\r\n            point: chain[0].prev.point,\r\n            cand: chain[0].prev.cand,\r\n            chainSet: chain[0].type === 'strong' ? 'no' as const : 'yes' as const\r\n        }]\r\n        : chain[0].prev.points.map(point => ({\r\n            point: point,\r\n            cand: chain[0].prev.cand,\r\n            chainSet: chain[0].type === 'strong' ? 'no' as const : 'yes' as const\r\n        }))\r\n\r\n    return [\r\n        ...first,\r\n        ...chain.flatMap(link => {\r\n            if(link.next.type === 'single'){\r\n                return [{\r\n                    point: link.next.point,\r\n                    cand: link.next.cand,\r\n                    chainSet: link.type === 'strong' ? 'yes' as const : 'no' as const\r\n                }]\r\n            }\r\n            return link.next.points.map(point => ({\r\n                point: point,\r\n                cand: link.next.cand,\r\n                chainSet: link.type === 'strong' ? 'yes' as const : 'no' as const\r\n            }))\r\n        }),\r\n    ]\r\n}\r\n\r\nconst chainIsAlternatingInternal = (chain: Link[]) => {\r\n    for(let i = 0; i < chain.length; i += 2){\r\n        if(!linkIsInternalWithinPoint(chain[i])) return false\r\n    }\r\n    return true\r\n}\r\n\r\n/**\r\n * Remote pairs are a chain of cells with the same two candidates, like a pair but at least 4 cells,\r\n * each affecting the next. E.g.\r\n * 45 45 45 45\r\n * Can be either\r\n *\r\n * 4  5  4  5\r\n * 5  4  5  4\r\n *\r\n * So if any cells in the chain length 3+2n apart has cells they see in common, we can eliminate the pair candidates from the cells in common.\r\n * Just like a normal naked pair actually, but with more steps.\r\n *\r\n * This implementation is basically the same as for xy chains, but with the restriction that all cells in\r\n * the chain must have the same candidates. This ensures that the result is actually a remote pair instead of an xy chain.\r\n * See comments below for more details.\r\n */\r\nexport function remotePairChain(board: SolverBoard){\r\n    const biValuePoints = getPointsWithNCandidates(board, getAllPoints(), 2)\r\n    const table = createTable(board, biValuePoints, allCandidates, false)\r\n\r\n    let result: any = null\r\n    const keepLink = (link: SingleLink) => {\r\n        // Every link is between pairs\r\n        return arraysEqual(\r\n            getBoardCell(board, link.prev.point).candidates,\r\n            getBoardCell(board, link.next.point).candidates,\r\n            (a, b) => a === b\r\n        )\r\n    }\r\n    const maxDepth = 12\r\n    iterateChainsInTable(table, keepLink, (chain: SingleLink[], isLoop) => {\r\n        if(isLoop) return false\r\n        if(chain.length <= 2) return false\r\n        const firstLink = chain[0]\r\n        const lastLink = chain[chain.length - 1]\r\n        // Starts and ends with strong link. Read this as:\r\n        // If we DON'T start with the candidate in the first cell of the chain\r\n        // then the last cell will definitely contain the candidate\r\n        // So the candidate is in either the first or the last cell\r\n        if(!(firstLink.type === 'strong' && lastLink.type === 'strong')){\r\n            return false\r\n        }\r\n        // Make sure that the ending candidate is actually the same as the starting candidate\r\n        if(firstLink.prev.cand !== lastLink.next.cand){\r\n            return false\r\n        }\r\n        // Only want those chains that take into account the links between pairs\r\n        if(!chainIsAlternatingInternal(chain)){\r\n            return false\r\n        }\r\n        const start = firstLink.prev.point\r\n        const end = lastLink.next.point\r\n        // Yes, we can eliminate both candidates.\r\n        // Why? Because we already check that all cells in the chain have the same two candidates.\r\n        // We can then start with the other candidate and arrive at the exact same conclusion.\r\n        const cands = getBoardCell(board, start).candidates\r\n        const affected = getAffectedPointsInCommon([start, end])\r\n        const effects = removeCandidatesFromPoints(board, affected, cands)\r\n\r\n        if(effects.length > 0){\r\n            result = {effects, actors: chainToActors(chain)}\r\n            return true\r\n        }\r\n    }, maxDepth)\r\n\r\n    return result\r\n}\r\n\r\n/**\r\n * x chains consider only one candidate in a chain.\r\n * It should start and end with a strong link.\r\n * An initial strong link means we start by NOT choosing the candidate, then follow the chain.\r\n * An ending strong link means that the final value will definitely be the candidate given the initial strong link.\r\n */\r\nexport function xChain(board: SolverBoard){\r\n    const unfilledPoints = getAllUnfilledPoints(board)\r\n    const table = createTable(board, unfilledPoints, allCandidates, false)\r\n\r\n    const maxDepth = 10\r\n    let result: any = null\r\n    const keepLink = (link: SingleLink) => link.prev.cand === link.next.cand\r\n    iterateChainsInTable(table, keepLink, (chain: SingleLink[], isLoop) => {\r\n        if(isLoop) return false\r\n        if(chain.length <= 2) return false\r\n        const firstLink = chain[0]\r\n        const lastLink = chain[chain.length - 1]\r\n        if(!(firstLink.type === 'strong' && lastLink.type === 'strong')){\r\n            return false\r\n        }\r\n        const start = firstLink.prev.point\r\n        const end = lastLink.next.point\r\n        const cand = firstLink.prev.cand\r\n        const affected = getAffectedPointsInCommon([start, end])\r\n        const effects = removeCandidatesFromPoints(board, affected, [cand])\r\n\r\n        if(effects.length > 0){\r\n            result = {effects, actors: chainToActors(chain)}\r\n            return true\r\n        }\r\n    }, maxDepth)\r\n\r\n    return result\r\n}\r\n\r\n\r\n/**\r\n * xy chains consider only bi value points\r\n * Like x chains and remote pairs, they must start and end with strong links\r\n * Also, the initial and final links must be on the same candidate.\r\n * This ensures that the candidate is in one of those cells.\r\n */\r\nexport function xyChain(board: SolverBoard){\r\n    const biValuePoints = getPointsWithNCandidates(board, getAllPoints(), 2)\r\n    const table = createTable(board, biValuePoints, allCandidates, false)\r\n\r\n    const maxDepth = 12\r\n    let result: any = null\r\n    const keepLink = () => true\r\n    iterateChainsInTable(table, keepLink, (chain: Link[], isLoop) => {\r\n        if(isLoop) return false\r\n        if(chain.length <= 2) return false\r\n        if(!chainIsAlternatingInternal(chain)) return false\r\n        const firstLink = chain[0] as SingleLink\r\n        const lastLink = chain[chain.length - 1] as SingleLink\r\n        // NOTE: We might restrict each strong link to be within cells as well.\r\n        // Right now we allow strong links to go directly to other cells.\r\n        // Not sure if this is still considered an xy chain. I guess it still is, but with fewer steps.\r\n        if(!(firstLink.type === 'strong' && lastLink.type === 'strong')){\r\n            return false\r\n        }\r\n        if(firstLink.prev.cand !== lastLink.next.cand){\r\n            return false\r\n        }\r\n        const start = firstLink.prev.point\r\n        const end = lastLink.next.point\r\n        const cand = firstLink.prev.cand\r\n        const affected = getAffectedPointsInCommon([start, end])\r\n        const effects = removeCandidatesFromPoints(board, affected, [cand])\r\n\r\n        if(effects.length > 0){\r\n            result = {effects, actors: chainToActors(chain)}\r\n            return true\r\n        }\r\n    }, maxDepth)\r\n\r\n    return result\r\n}\r\n\r\nconst getDiscontinuousNiceLoop = (board: SolverBoard, chain: Link[], isLoop: boolean) => {\r\n    if(!isLoop){\r\n        return null\r\n    }\r\n\r\n    const firstLink = chain[0] as SingleLink\r\n    const lastLink = chain[chain.length - 1] as SingleLink\r\n\r\n    // first OFF and last ON and same cand -> contradiction. It must be the candidate\r\n    if(firstLink.type === 'strong' && lastLink.type === 'strong' && firstLink.prev.cand === lastLink.next.cand){\r\n        const effects = removeCandidatesFromPoints(board, [firstLink.prev.point], candidatesExcept([firstLink.prev.cand]))\r\n        if(effects.length > 0){\r\n            return {effects, actors: chainToActors(chain)}\r\n        }\r\n    }\r\n    // first ON and last OFF and same cand -> contradiction. It can't be the candidate\r\n    if(firstLink.type === 'weak' && lastLink.type === 'weak' && firstLink.prev.cand === lastLink.next.cand){\r\n        const effects = removeCandidatesFromPoints(board, [firstLink.prev.point], [firstLink.prev.cand])\r\n        if(effects.length > 0){\r\n            return {effects, actors: chainToActors(chain)}\r\n        }\r\n    }\r\n\r\n    // first ON and last ON and not same cand -> contradiction. It can't be the candidate\r\n    if(firstLink.type === 'weak' && lastLink.type === 'strong' && firstLink.prev.cand !== lastLink.next.cand){\r\n        const effects = removeCandidatesFromPoints(board, [firstLink.prev.point], [firstLink.prev.cand])\r\n        if(effects.length > 0){\r\n            return {effects, actors: chainToActors(chain)}\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nconst getContinuousNiceLoop = (board: SolverBoard, chain: Link[], isLoop: boolean) => {\r\n    if(!isLoop){\r\n        return null\r\n    }\r\n\r\n    const firstLink = chain[0] as SingleLink\r\n    const lastLink = chain[chain.length - 1] as SingleLink\r\n\r\n    if(\r\n        (\r\n            (firstLink.type === 'weak' && lastLink.type === 'strong') ||\r\n            (firstLink.type === 'strong' && lastLink.type === 'weak')\r\n        ) &&\r\n        firstLink.prev.cand === lastLink.next.cand\r\n    ){\r\n        const pointsInChain = chain.flatMap(link => getNodePoints(link.next)) // It's a loop, so the first point is included\r\n        const weakSingleLinks = chain.filter(link => link.type === 'weak')\r\n\r\n        const effects: Effect[] = []\r\n\r\n        for(let link of weakSingleLinks){\r\n            // TODO: What about internal links with grouping? Think it doesn't matter..\r\n            if(linkIsInternalWithinPoint(link) && link.prev.type === 'single' && link.next.type === 'single'){\r\n                effects.push(\r\n                    ...removeCandidatesFromPoints(board, [link.prev.point], candidatesExcept([link.prev.cand, link.next.cand]))\r\n                )\r\n            }else{\r\n                let pointsToRemove: Point[] = []\r\n                const prevPoints = getNodePoints(link.prev)\r\n                const nextPoints = getNodePoints(link.next)\r\n\r\n                // link within box\r\n                const prevBoxes = unique(prevPoints.map(getBoxNumber))\r\n                const nextBoxes = unique(nextPoints.map(getBoxNumber))\r\n                if(prevBoxes.length === 1 && nextBoxes.length === 1 && prevBoxes[0] === nextBoxes[0]){\r\n                    pointsToRemove.push(...getBox(prevPoints[0]))\r\n                }\r\n\r\n                // link within column\r\n                const prevCols = unique(prevPoints.map(getColNumber))\r\n                const nextCols = unique(nextPoints.map(getColNumber))\r\n                if(prevCols.length === 1 && nextCols.length === 1 && prevCols[0] === nextCols[0]){\r\n                    pointsToRemove.push(...getColumn(prevPoints[0].x))\r\n                }\r\n\r\n                // link within row\r\n                const prevRows = prevPoints.map(getRowNumber)\r\n                const nextRows = nextPoints.map(getRowNumber)\r\n                if(prevRows.length === 1 && nextRows.length === 1 && prevRows[0] === nextRows[0]){\r\n                    pointsToRemove.push(...getRow(prevPoints[0].y))\r\n                }\r\n                pointsToRemove = difference(pointsToRemove, pointsInChain, pointsEqual)\r\n                const cand = link.next.cand\r\n                effects.push(\r\n                    ...removeCandidatesFromPoints(board, pointsToRemove, [cand])\r\n                )\r\n            }\r\n        }\r\n        if(effects.length > 0){\r\n            return {effects, actors: chainToActors(chain)}\r\n        }\r\n    }\r\n    return null\r\n}\r\n\r\nconst getAicType1 = (board: SolverBoard, chain: Link[], isLoop: boolean) => {\r\n    if(isLoop){\r\n        return null\r\n    }\r\n\r\n    const firstLink = chain[0] as SingleLink\r\n    const lastLink = chain[chain.length - 1] as SingleLink\r\n\r\n    if(firstLink.type === 'strong' && lastLink.type === 'strong' && firstLink.prev.cand === lastLink.next.cand){\r\n        const cand = firstLink.prev.cand\r\n        const affected = getAffectedPointsInCommon([firstLink.prev.point, lastLink.next.point])\r\n        const effects = removeCandidatesFromPoints(board, affected, [cand])\r\n\r\n        if(effects.length > 0){\r\n            return {effects, actors: chainToActors(chain)}\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nconst getAicType2 = (board: SolverBoard, chain: Link[], isLoop: boolean) => {\r\n    if(isLoop){\r\n        return null\r\n    }\r\n\r\n    const firstLink = chain[0] as SingleLink\r\n    const lastLink = chain[chain.length - 1] as SingleLink\r\n\r\n    if(firstLink.type === 'strong' && lastLink.type === 'strong' && firstLink.prev.cand !== lastLink.next.cand){\r\n        if(pointsSeeEachOther(firstLink.prev.point, lastLink.next.point)){\r\n            const effects = [\r\n                ...removeCandidateFromPoints(board, [firstLink.prev.point], lastLink.next.cand),\r\n                ...removeCandidateFromPoints(board, [lastLink.next.point], firstLink.prev.cand)\r\n            ]\r\n\r\n            if(effects.length > 0){\r\n                return {effects, actors: chainToActors(chain)}\r\n            }\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nconst isGrouped = (chain: Link[]) => chain.some(link => link.prev.type === 'group' || link.next.type === 'group')\r\n\r\nexport const createFindChain = (board: SolverBoard, allowStopEarly = true) => {\r\n    const results: {name: string, result: TechniqueResult, depth: number}[] = []\r\n    const addResult = (result: TechniqueResult | null, name: string, chain) => {\r\n        if(result !== null){\r\n            const grouped = isGrouped(chain) ? 'Grouped' : ''\r\n            results.push({name: name + grouped, result, depth: chain.length})\r\n        }\r\n    }\r\n\r\n    let checked = 0\r\n\r\n    /*\r\n    Normally we check all chains up to a certain depth before stopping.\r\n    The reason is that we don't want to do the whole thing again when looking for the next chain type.\r\n    But looking through all these chains can be slow, and so we have to set the max depth to a low value.\r\n    Instead, we can have a middle ground with an early-stop criteria, and can therefore increase the depth slightly.\r\n     */\r\n    const shouldStopEarly = (depth: number) => {\r\n        if (!allowStopEarly) {\r\n            return false\r\n        }\r\n        // Stop it from running forever in case the number of chains in each depth is totally crazy\r\n        if (checked++ > 1000000) {\r\n            return true\r\n        }\r\n        if (results.length === 0) {\r\n            return false\r\n        }\r\n        // Favor loops\r\n        if (results.some(x => x.name.includes('loop'))) {\r\n            return true\r\n        }\r\n        // But we'll take an aic if it has more than one elimination\r\n        if (results.some(x => x.name.includes('aic') && x.result.effects.length > 1)) {\r\n            return true\r\n        }\r\n        // If we have a significantly shorter chain, always take it\r\n        if (results.some(x => x.depth <= depth - 2)) {\r\n            return true\r\n        }\r\n        return false\r\n    }\r\n\r\n    let initialized = false\r\n\r\n    const init = (name) => {\r\n        initialized = true\r\n        const maxDepth = 12\r\n        const unfilledPoints = getAllUnfilledPoints(board)\r\n        const table = createTable(board, unfilledPoints, allCandidates, true)\r\n        const keepLink = () => true\r\n        let depth = 0\r\n\r\n        iterateChainsInTable(table, keepLink, (chain: Link[], isLoop) => {\r\n            if(chain.length <= 2) return false\r\n\r\n            if(chain.length > depth){\r\n                depth = chain.length\r\n                // console.log(depth)\r\n            }\r\n\r\n            addResult(getDiscontinuousNiceLoop(board, chain, isLoop), 'discontinuousNiceLoop', chain)\r\n            addResult(getAicType1(board, chain, isLoop), 'aicType1', chain)\r\n            addResult(getAicType2(board, chain, isLoop), 'aicType2', chain)\r\n            addResult(getContinuousNiceLoop(board, chain, isLoop), 'continuousNiceLoop', chain)\r\n\r\n            if (shouldStopEarly(depth)) {\r\n                return true\r\n            }\r\n\r\n            return results.some(x => x.name === name)\r\n        }, maxDepth)\r\n\r\n        results.sort((a, b) => {\r\n            const actorsDiff = a.result.actors.length - b.result.actors.length\r\n            const effectsDiff = b.result.effects.length - a.result.effects.length\r\n            return actorsDiff !== 0 ? actorsDiff : effectsDiff\r\n        })\r\n    }\r\n\r\n    return (name) => {\r\n        if(!initialized){\r\n            init(name)\r\n        }\r\n        return results.find(x => x.name === name)?.result ?? null\r\n    }\r\n}\r\n\r\nexport const aicType1 = (findChain) => () => findChain('aicType1')\r\nexport const aicType2 = (findChain) => () => findChain('aicType2')\r\nexport const aicType1Grouped = (findChain) => () => findChain('aicType1Grouped')\r\nexport const aicType2Grouped = (findChain) => () => findChain('aicType2Grouped')\r\nexport const discontinuousNiceLoop = (findChain) => () => findChain('discontinuousNiceLoop')\r\nexport const discontinuousNiceLoopGrouped = (findChain) => () => findChain('discontinuousNiceLoopGrouped')\r\nexport const continuousNiceLoop = (findChain) => () => findChain('continuousNiceLoop')\r\nexport const continuousNiceLoopGrouped = (findChain) => () => findChain('continuousNiceLoopGrouped')","import { SolverBoard } from '../types'\r\nimport { removeCandidateFromAffectedPoints } from '../utils/effects'\r\nimport { allResults, first  } from '../utils/misc'\r\nimport {\r\n    allCandidates, cloneBoard, getAllHousesMinusFilledPoints,\r\n    getAllUnfilledPoints,\r\n    getBoardCell, getPointsWithCandidates,\r\n    getPointsWithNCandidates\r\n} from '../utils/sudokuUtils'\r\n\r\n/**\r\n * A BUG (binary universal grave) occurs when all cells have two candidates,\r\n * and all candidates appear twice in the houses it's in.\r\n * In case of a BUG, there cannot be a unique solution to the puzzle.\r\n */\r\nconst hasBug = (board: SolverBoard) => {\r\n    const allCellsHaveTwoCands = getAllUnfilledPoints(board).every(point => getBoardCell(board, point).candidates.length === 2)\r\n    if(!allCellsHaveTwoCands) return false\r\n\r\n    for(let cand of allCandidates){\r\n        for(let house of getAllHousesMinusFilledPoints(board)){\r\n            const occurrences = getPointsWithCandidates(board, house, [cand]).length\r\n            if(occurrences !== 2 && occurrences !== 0) return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\n/**\r\n * A BUG+1 is when there is a BUG plus one extra candidate in one cell.\r\n * This candidate must be placed to avoid the BUG.\r\n */\r\nfunction *bugPlus1Generator(board: SolverBoard){\r\n    const unfilled = getAllUnfilledPoints(board)\r\n    const triValuePoints = getPointsWithNCandidates(board, unfilled, 3)\r\n\r\n    if(triValuePoints.length !== 1) return null\r\n\r\n    const biValuePoints = getPointsWithNCandidates(board, unfilled, 2)\r\n\r\n    if(triValuePoints.length + biValuePoints.length !== unfilled.length) return null\r\n\r\n    const triValuePoint = triValuePoints[0]\r\n    const triValueCell = getBoardCell(board, triValuePoints[0])\r\n\r\n    const clonedBoard = cloneBoard(board)\r\n\r\n    for(let extraCand of triValueCell.candidates){\r\n        // Temporarily remove the cand to check if there is a bug left\r\n        clonedBoard[triValuePoint.y][triValuePoint.x].candidates = clonedBoard[triValuePoint.y][triValuePoint.x].candidates.filter(c => c !== extraCand)\r\n        const bug = hasBug(clonedBoard)\r\n        clonedBoard[triValuePoint.y][triValuePoint.x].candidates.push(extraCand)\r\n\r\n        if(bug){\r\n            yield {\r\n                actors: biValuePoints.map(point => ({point})),\r\n                effects: [\r\n                    {type: 'value', point: triValuePoint, number: extraCand} as const,\r\n                    ...removeCandidateFromAffectedPoints(board, triValuePoint, extraCand)\r\n                ]\r\n            }\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport const bugPlus1 = (board: SolverBoard) => first(bugPlus1Generator(board))\r\nexport const allBugPlus1 = (board: SolverBoard) => allResults(bugPlus1Generator(board))","import { EliminationEffect, Point, SolverBoard } from '../types'\r\nimport { allCandidates, getAffectedPoints, getAllUnfilledPoints, getPointsWithCandidates } from '../utils/sudokuUtils'\r\nimport { createTable, getPointKey, SingleTable } from './chainGraph'\r\nimport { allResults, first, unique } from '../utils/misc'\r\nimport { removeCandidateFromPoints } from '../utils/effects'\r\n\r\nfunction *simpleColoringGenerator(board: SolverBoard){\r\n    const unfilledPoints = getAllUnfilledPoints(board)\r\n    const table: SingleTable = createTable(board, unfilledPoints, allCandidates, false) as SingleTable\r\n    const oppositeColor = (color) => color === 'yes' ? 'no' : 'yes'\r\n\r\n    const getNextQueueItems = (pointKey: number, cand: number, color: string) => {\r\n        return table[pointKey].links\r\n            .filter(link => link.prev.cand === cand && link.next.cand === cand && link.type === 'strong')\r\n            .map(link => ({ point: link.next.point, color }))\r\n    }\r\n\r\n    const colorFromPoint = (startingPoint: Point, cand: number) => {\r\n        const startingKey = getPointKey(startingPoint)\r\n        const colors = {[startingKey]: { color: 'yes', point: startingPoint }}\r\n        const queue = getNextQueueItems(startingKey, cand, 'no')\r\n\r\n        while(queue.length > 0){\r\n            const { point, color } = queue.shift()!\r\n\r\n            const key = getPointKey(point)\r\n            if(colors[key]) continue\r\n            colors[key] = {color, point}\r\n\r\n            queue.push(...getNextQueueItems(key, cand, oppositeColor(color)))\r\n        }\r\n\r\n        return colors\r\n    }\r\n\r\n    // Sort so we get easier results first\r\n    const candsWithPoints = allCandidates\r\n        .map(cand => {\r\n            return {\r\n                cand,\r\n                points: getPointsWithCandidates(board, unfilledPoints, [cand])\r\n            }\r\n        })\r\n        .sort((a, b) => a.points.length - b.points.length)\r\n\r\n    for(let { cand, points } of candsWithPoints){\r\n        // Avoid checking points within the same coloring multiple times\r\n        const checked = new Set()\r\n        for(let startingPoint of points){\r\n            if(checked.has(getPointKey(startingPoint))) continue\r\n\r\n            const colors = colorFromPoint(startingPoint, cand)\r\n\r\n            Object.values(colors).forEach(({point}) => {\r\n                checked.add(getPointKey(point))\r\n            })\r\n\r\n            if(Object.values(colors).length > 18) continue // 9*2=18, that is each e.g. row has a conjugate pair. Doesn't make sense to color in more than that?\r\n\r\n            const uncoloredPoints = points.filter(point => !colors[getPointKey(point)])\r\n\r\n            const effects: EliminationEffect[] = []\r\n\r\n            // Check color traps:\r\n            // All points seeing two different colors must be eliminated, since one of those colors must mean that the cand is set\r\n            for(let uncoloredPoint of uncoloredPoints){\r\n                const seenColors = unique(\r\n                    getAffectedPoints(uncoloredPoint)\r\n                        .map(affected => colors[getPointKey(affected)]?.color ?? '')\r\n                        .filter(color => color !== '')\r\n                )\r\n\r\n                if(seenColors.length === 2){\r\n                    effects.push(...removeCandidateFromPoints(board, [uncoloredPoint], cand))\r\n                }\r\n            }\r\n\r\n            // Check color wraps:\r\n            // Points with the same color seeing each other must all be false\r\n            for(let {point, color} of Object.values(colors)){\r\n                const seesSameColor = getAffectedPoints(point)\r\n                    .some(affected => colors[getPointKey(affected)]?.color === color)\r\n\r\n                if(seesSameColor){\r\n                    effects.push(...removeCandidateFromPoints(board, [point], cand))\r\n                }\r\n            }\r\n\r\n            const actors = Object.values(colors).map(x => ({point: x.point, cand, chainSet: x.color}))\r\n\r\n            if(effects.length > 0){\r\n                yield {effects, actors}\r\n            }\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport const simpleColoring = (board: SolverBoard) => first(simpleColoringGenerator(board))\r\nexport const allSimpleColorings = (board: SolverBoard) => allResults(simpleColoringGenerator(board))","import { Board, SolverBoard, SolveResult } from './types'\r\nimport { allBasicEliminations, basicElimination } from './solvers/basic'\r\nimport { fullHouse, hiddenSingle, nakedSingle } from './solvers/singles'\r\nimport { inversePointer, pointer } from './solvers/pointer'\r\nimport { hiddenPair, hiddenQuad, hiddenTriple, nakedPair, nakedQuad, nakedTriple } from './solvers/subset'\r\nimport {\r\n    jellyfish, jellyfishFinned, jellyfishFinnedSashimi,\r\n    swordfish,\r\n    swordfishFinned,\r\n    swordfishFinnedSashimi,\r\n    xWing,\r\n    xWingFinned,\r\n    xWingFinnedSashimi\r\n} from './solvers/fish'\r\nimport { hiddenRectangle, uniqueRectangle1 } from './solvers/uniqueRectangle'\r\nimport { skyscraper } from './solvers/skyscraper'\r\nimport { emptyRectangle } from './solvers/emptyRectangle'\r\nimport { wWing, xyWing, xyzWing } from './solvers/wing'\r\nimport { boardHasError, isBoardFinished, mergeResults } from './utils/sudokuUtils'\r\nimport { unique } from './utils/misc'\r\nimport { applyEffects } from './utils/effects'\r\nimport { bruteForce } from './solvers/bruteForce'\r\nimport {\r\n    aicType1,\r\n    aicType1Grouped,\r\n    aicType2,\r\n    aicType2Grouped,\r\n    continuousNiceLoop,\r\n    continuousNiceLoopGrouped, createFindChain,\r\n    discontinuousNiceLoop,\r\n    discontinuousNiceLoopGrouped,\r\n    remotePairChain,\r\n    xChain,\r\n    xyChain\r\n} from './solvers/chains'\r\nimport { bugPlus1 } from './solvers/bug'\r\nimport { simpleColoring } from './solvers/simpleColoring'\r\n\r\nexport const techniques = [\r\n    {type: 'basic', difficulty: 'beginner'},\r\n    {type: 'fullHouse', difficulty: 'beginner'}, // Easy newspaper style\r\n    {type: 'hiddenSingle', difficulty: 'easy'}, // Can be easy or hard tbh, but with highlighting it's often easy\r\n    {type: 'pointer', difficulty: 'medium'},\r\n    {type: 'inversePointer', difficulty: 'medium'},\r\n    {type: 'nakedSingle', difficulty: 'medium'}, // Note: Fullhouse is included earlier, so this naked single might actually be very hard to find sometimes\r\n    {type: 'nakedPair', difficulty: 'medium'},\r\n    {type: 'hiddenPair', difficulty: 'hard'},\r\n    {type: 'xWing', difficulty: 'hard'}, // When you know about it, easier than triples\r\n    {type: 'nakedTriple', difficulty: 'hard'},\r\n    {type: 'hiddenTriple', difficulty: 'hard'},\r\n    {type: 'nakedQuad', difficulty: 'hard'}, // At least it's naked, but 4 is a lot :P\r\n    {type: 'uniqueRectangle1', difficulty: 'expert'}, // Type 1 is quite easy to spot when you know about it. The others, not so much.\r\n    {type: 'bugPlus1', difficulty: 'expert'}, // BUG+1 is a quick way to finish a puzzle\r\n    {type: 'skyscraper', difficulty: 'expert'}, // A bit harder than x-wing. A bit more chainy\r\n    {type: 'swordfish', difficulty: 'expert'}, // Quite hard to spot, but easier with highlighting\r\n    {type: 'emptyRectangle', difficulty: 'expert'}, // Not too hard to spot when you know about it. A bit chainy\r\n    {type: 'hiddenQuad', difficulty: 'expert'}, // Quite hard to spot imo, but not chainy\r\n    {type: 'xWingFinned', difficulty: 'expert'},\r\n    {type: 'xWingFinnedSashimi', difficulty: 'expert'},\r\n    {type: 'remotePairChain', difficulty: 'artisan'}, // Easy chain to spot if you have all candidates\r\n    {type: 'wWing', difficulty: 'artisan'}, // More of a pattern than xyWing imo\r\n    {type: 'hiddenRectangle', difficulty: 'artisan'}, // Much harder than unique rect type 1\r\n    {type: 'jellyfish', difficulty: 'artisan'}, // Highlights is a must for jellyfish\r\n    {type: 'xyWing', difficulty: 'artisan'}, // Chainy. Quite hard to spot\r\n    {type: 'xyzWing', difficulty: 'artisan'}, // Same as xywing, but even more digits, so a bit harder.\r\n    {type: 'swordfishFinned', difficulty: 'artisan'},\r\n    {type: 'swordfishFinnedSashimi', difficulty: 'artisan'},\r\n    {type: 'simpleColoring', difficulty: 'master'}, // Quite time consuming, but not actually that hard\r\n    {type: 'xChain', difficulty: 'master'}, // Let's have a stare shall we?\r\n    {type: 'xyChain', difficulty: 'master'}, // Stare even harder...\r\n    {type: 'jellyfishFinned', difficulty: 'jedi'},\r\n    {type: 'jellyfishFinnedSashimi', difficulty: 'jedi'},\r\n    {type: 'discontinuousNiceLoop', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'aicType1', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'aicType2', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'continuousNiceLoop', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'discontinuousNiceLoopGrouped', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'aicType1Grouped', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'aicType2Grouped', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'continuousNiceLoopGrouped', difficulty: 'jedi'}, // Stare even more harder...\r\n    {type: 'bruteForce', difficulty: 'jedi'} // Stare for days\r\n]\r\n\r\nconst createTechniqueRunners = (board: SolverBoard) => {\r\n    const findChain = createFindChain(board)\r\n    return {\r\n        basic: basicElimination,\r\n        fullHouse,\r\n        hiddenSingle,\r\n        pointer,\r\n        inversePointer,\r\n        nakedSingle,\r\n        nakedPair,\r\n        hiddenPair,\r\n        xWing,\r\n        nakedTriple,\r\n        hiddenTriple,\r\n        nakedQuad,\r\n        uniqueRectangle1,\r\n        bugPlus1,\r\n        skyscraper,\r\n        swordfish,\r\n        emptyRectangle,\r\n        hiddenQuad,\r\n        xWingFinned,\r\n        xWingFinnedSashimi,\r\n        remotePairChain,\r\n        hiddenRectangle,\r\n        wWing,\r\n        jellyfish: jellyfish,\r\n        xyWing,\r\n        xyzWing,\r\n        swordfishFinned,\r\n        swordfishFinnedSashimi,\r\n        simpleColoring,\r\n        xChain,\r\n        xyChain,\r\n        jellyfishFinned,\r\n        jellyfishFinnedSashimi,\r\n        discontinuousNiceLoop: discontinuousNiceLoop(findChain),\r\n        aicType1: aicType1(findChain),\r\n        aicType2: aicType2(findChain),\r\n        continuousNiceLoop: continuousNiceLoop(findChain),\r\n        discontinuousNiceLoopGrouped: discontinuousNiceLoopGrouped(findChain),\r\n        aicType1Grouped: aicType1Grouped(findChain),\r\n        aicType2Grouped: aicType2Grouped(findChain),\r\n        continuousNiceLoopGrouped: continuousNiceLoopGrouped(findChain),\r\n        bruteForce: bruteForce,\r\n    }\r\n}\r\n\r\nexport const difficulties = unique(techniques.map(t => t.difficulty))\r\n\r\nexport const difficultyLevels = {\r\n    beginner: 0,\r\n    easy: 1,\r\n    medium: 2,\r\n    hard: 3,\r\n    expert: 4,\r\n    artisan: 5,\r\n    master: 6,\r\n    jedi: 7\r\n}\r\nexport const getDifficultyLevel = (difficulty: string) => difficultyLevels[difficulty]\r\n\r\nexport const getDifficulty = (techniqueType: string) => {\r\n    const difficulty = techniques.find(t => t.type === techniqueType)!.difficulty\r\n    return {difficulty, level: difficultyLevels[difficulty]}\r\n}\r\nexport const getOverallDifficulty = (techniqueTypes: string[]) => {\r\n    const difficulty = [...techniques].reverse().find(t => techniqueTypes.includes(t.type))!.difficulty\r\n    return {difficulty, level: difficultyLevels[difficulty]}\r\n}\r\n\r\nexport const getSolution = (board: SolverBoard) => {\r\n    return applyTechniques(board, ['bruteForce'])\r\n}\r\n\r\n/**\r\n * Runs techniques in order until one that works is found\r\n */\r\nexport const runTechnique = (board: SolverBoard) => {\r\n    const techniqueRunners = createTechniqueRunners(board)\r\n    for(let technique of techniques){\r\n        const result = techniqueRunners[technique.type](board)\r\n        if(result){\r\n            return {\r\n                ...result,\r\n                technique: technique.type\r\n            }\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n\r\n/**\r\n * Apply given techniques until the board is solved, or the techniques don't work anymore\r\n */\r\nexport const applyTechniques = (board: SolverBoard, techniqueTypes: string[]): Board => {\r\n    while(true){\r\n        if(isBoardFinished(board)){\r\n            return board\r\n        }\r\n        let moreToGo = false\r\n        for(let techType of techniqueTypes){\r\n            const techniqueRunners = createTechniqueRunners(board)\r\n            const tech = techniques.find(t => t.type === techType)\r\n            if(!tech) throw new Error('Unknown technique type')\r\n            const res = techniqueRunners[tech.type](board)\r\n            if(res){\r\n                board = applyEffects(board, res.effects)\r\n                moreToGo = true\r\n            }\r\n        }\r\n        if(!moreToGo){\r\n            return board\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Basic elimination is just using the constraints of sudoku alone\r\n */\r\nexport const applyBasicEliminations = (board: SolverBoard): SolverBoard => {\r\n    const result = mergeResults(allBasicEliminations(board))\r\n    return applyEffects(board, result.effects)\r\n}\r\n\r\n/**\r\n * Board needs to be prepared with all candidates before running iterate\r\n */\r\nexport const iterate = (board: SolverBoard): SolveResult | null => {\r\n    const result = runTechnique(board)\r\n    if(result){\r\n        board = applyEffects(board, result.effects)\r\n        return {board, ...result}\r\n    }\r\n\r\n    if(isBoardFinished(board)){\r\n        return {board, effects: [], actors: [], technique: 'done'}\r\n    }\r\n\r\n    return null\r\n}\r\n\r\nexport const getTechniquesRequiredForSolvingBoard = (board: SolverBoard) => {\r\n    const solution = getSolution(board)\r\n\r\n    const techniques: string[] = []\r\n    while(true){\r\n        const res = iterate(board)\r\n        if(res === null){\r\n            throw new Error('Unsupported technique required')\r\n        }\r\n        if(boardHasError(board, solution)){\r\n            throw new Error('Board has error ' + techniques.join(', '))\r\n        }\r\n        if(res.technique === 'done'){\r\n            break\r\n        }\r\n        board = res.board\r\n        techniques.push(res.technique)\r\n    }\r\n    return unique(techniques)\r\n}","import { Board, Cell, Effect, InputMode, Point, SolverBoard } from './types'\r\nimport { allCandidates, cloneBoard, getAllPoints } from './utils/sudokuUtils'\r\nimport { applyEffects, toggleCandidate, toggleValue } from './utils/effects'\r\nimport * as solve from './solve'\r\n\r\nexport const boardFromInput = (input: number[][]) => {\r\n    let board: Board = []\r\n    for(let y = 0; y < 9; y++){\r\n        let row: Cell[] = []\r\n        for(let x = 0; x < 9; x++){\r\n            if(input[y][x] !== 0){\r\n                row.push({\r\n                    value: input[y][x],\r\n                    given: true,\r\n                    candidates: []\r\n                })\r\n            }else{\r\n                row.push({\r\n                    value: null,\r\n                    given: false,\r\n                    candidates: []\r\n                })\r\n            }\r\n        }\r\n        board.push(row)\r\n    }\r\n    return board\r\n}\r\n\r\nexport const boardFromStr = (input: string) => {\r\n    return boardFromInput(\r\n        [...input.matchAll(/\\d{9}/g)]\r\n            .map(x => x[0].split('').map(Number))\r\n    )\r\n}\r\n\r\nexport const boardToStr = (board: Board) => {\r\n    let boardStr = ''\r\n    for(let y = 0; y < 9; y++){\r\n        for(let x = 0; x < 9; x++){\r\n            const cell = board[y][x]\r\n            boardStr += cell.value === null ? '0' : String(cell.value)\r\n        }\r\n    }\r\n    return boardStr\r\n}\r\n\r\nexport const resetCandidates = (board: Board): SolverBoard => {\r\n    board = cloneBoard(board)\r\n    for(let point of getAllPoints()){\r\n        board[point.y][point.x].candidates = board[point.y][point.x].value === null ? allCandidates : []\r\n    }\r\n    return board as SolverBoard\r\n}\r\n\r\nexport const applyInputValue = (board: Board, points: Point[], digit: number, mode: InputMode): Board => {\r\n    let effects: Effect[] = []\r\n    if(points.length === 1){\r\n        if(mode === 'candidates'){\r\n            effects = toggleCandidate(board, points, digit)\r\n        }else if(mode === 'value'){\r\n            effects = toggleValue(board, points[0], digit)\r\n        }\r\n    }else if(points.length >= 2){\r\n        effects = toggleCandidate(board, points, digit)\r\n    }\r\n\r\n    return applyEffects(board, effects)\r\n}\r\n\r\nexport const prepareBoardForSolver = (board: Board): SolverBoard => {\r\n    board = resetCandidates(board)\r\n    board = solve.applyBasicEliminations(board)\r\n    return board\r\n}\r\n\r\n/**\r\n * Iterates solver until the next digit can be placed.\r\n */\r\nexport const getTechniquesUntilNextValue = (board: SolverBoard) => {\r\n    const techniques: string[] = []\r\n\r\n    let res = solve.iterate(board)\r\n    res !== null && techniques.push(res.technique)\r\n\r\n    while(res !== null && res.technique !== 'done' && !res.effects.some(eff => eff.type === 'value')){\r\n        res = solve.iterate(res.board)\r\n        res !== null && techniques.push(res.technique)\r\n    }\r\n\r\n    return techniques\r\n}","import { createSelector } from 'reselect'\r\nimport { Board } from './core/types'\r\nimport { getSolution } from './core/solve'\r\nimport { boardHasError, boardIsComplete } from './core/utils/sudokuUtils'\r\nimport { getTechniquesUntilNextValue, prepareBoardForSolver } from './core/sudoku'\r\nimport { State, UserData } from './state'\r\nimport { BoardMetaData } from './core/utils/getBoardMetaData'\r\n\r\nexport const selectSolution = createSelector(\r\n    (state: State) => state.game?.initialBoard ?? null,\r\n    (board: Board | null) => {\r\n        if (!board) return null\r\n        return getSolution(board)\r\n    }\r\n)\r\nexport const selectHasError = createSelector(\r\n    (state: State) => state.game?.board ?? null,\r\n    selectSolution,\r\n    (board: Board | null, solution: Board | null) => {\r\n        if (!board || !solution) return null\r\n        return boardHasError(board, solution)\r\n    }\r\n)\r\nexport const selectIsComplete = createSelector(\r\n    (state: State) => state.game?.board ?? null,\r\n    (board: Board | null) => {\r\n        if (!board) return false\r\n        return boardIsComplete(board)\r\n    }\r\n)\r\nexport const selectHints = createSelector(\r\n    (state: State) => state.game?.board ?? null,\r\n    selectHasError,\r\n    (board: Board | null, hasError: boolean | null) => {\r\n        if (!board || hasError === null) return []\r\n        if (hasError) return []\r\n        return getTechniquesUntilNextValue(prepareBoardForSolver(board))\r\n    }\r\n)\r\nexport const selectPuzzles = createSelector(\r\n    (state: State) => state.puzzles,\r\n    (puzzles: BoardMetaData[]) => puzzles\r\n)\r\nexport const selectUserData = createSelector(\r\n    (state: State) => state.userData,\r\n    (userData: UserData) => userData\r\n)","import {\r\n    Actor,\r\n    Board,\r\n    Cell,\r\n    Effect,\r\n    EliminationEffect,\r\n    Point,\r\n    SolveResult,\r\n    ValueEffect\r\n} from '../core/types'\r\nimport React from 'react'\r\nimport { allCandidates, getAffectedPoints, getBoardCell, getPointId, pointsEqual } from '../core/utils/sudokuUtils'\r\nimport useEventListener from '@use-it/event-listener'\r\nimport {\r\n    actorCandidateColor, actorChainCandidateNoColor, actorChainCandidateYesColor,\r\n    actorColor,\r\n    affectedColor,\r\n    boardBackgroundColor,\r\n    boardBorderColor,\r\n    boardBorderHardColor, eliminateCandidateColor,\r\n    eliminationColor,\r\n    errorColor,\r\n    getContrastText, highlightedCandidateColor,\r\n    highlightedColor,\r\n    selectedColor,\r\n    selectedDigitHighlightColor, setCandidateColor,\r\n    setValueColor\r\n} from '../theme'\r\nimport { darken } from '@material-ui/core/styles'\r\nimport { actions } from '../index'\r\nimport { useSelector } from 'react-redux'\r\nimport { State } from '../state'\r\nimport { selectSolution } from '../selectors'\r\n\r\nconst Candidates = (props) => {\r\n    const height = props.height\r\n    const fontSize = height / 4\r\n\r\n    return (\r\n        <div\r\n            style={{\r\n                display: 'grid',\r\n                gridTemplateColumns: '1fr 1fr 1fr',\r\n                gridTemplateRows: '1fr 1fr 1fr',\r\n                gap: 0,\r\n                width: '100%',\r\n                height: '100%',\r\n                fontSize: fontSize,\r\n                fontFamily: 'monospace',\r\n                color: 'inherit'\r\n            }}\r\n        >\r\n            {allCandidates.map(number => {\r\n                return (\r\n                    <div\r\n                        style={{\r\n                            background: props.bgs[number] ?? '',\r\n                            width: '100%',\r\n                            height: '100%',\r\n                            display: 'flex',\r\n                            justifyContent: 'center',\r\n                            alignItems: 'center'\r\n                        }}\r\n                        key={number}\r\n                    >\r\n                        {props.candidates.includes(number) && number}\r\n                    </div>\r\n                )\r\n            })}\r\n        </div>\r\n    )\r\n}\r\n\r\ntype CellDisplayProps = {\r\n    solveResult: SolveResult | null\r\n    selected: boolean\r\n    affected: boolean\r\n    cell: Cell\r\n    cellHeight: number\r\n    point: Point\r\n    highlightedNumber: number | null\r\n    selectedDigit: number | null\r\n    hasError: boolean\r\n    celebration: boolean\r\n}\r\n\r\nconst cellHasElimination = (effects: Effect[], point: Point) => effects\r\n    .filter((eff: Effect) => eff.type === 'elimination')\r\n    .some((eff) => pointsEqual((eff as EliminationEffect).point, point))\r\n\r\nconst cellHasSetValue = (effects: Effect[], point: Point) => effects\r\n    .filter((eff: Effect) => eff.type === 'value')\r\n    .some((eff) => pointsEqual((eff as ValueEffect).point, point))\r\n\r\nconst cellHasActor = (actors: Actor[], point: Point) => actors\r\n    .some(actor => pointsEqual(actor.point, point))\r\n\r\nconst getCellBackgroundColor = (\r\n    actors: Actor[],\r\n    effects: Effect[],\r\n    point: Point,\r\n    cell: Cell,\r\n    affected: boolean,\r\n    selected: boolean,\r\n    highlightedNumber: number | null,\r\n    selectedDigit: number | null,\r\n    hasError: boolean\r\n) => {\r\n    const hasElimination = cellHasElimination(effects, point)\r\n    const hasSetValue = cellHasSetValue(effects, point)\r\n    const hasActor = cellHasActor(actors, point)\r\n\r\n    let bg = boardBackgroundColor\r\n    if(affected) bg = affectedColor\r\n    if(hasElimination) bg = eliminationColor\r\n    if(hasActor) bg = actorColor\r\n    if(hasSetValue) bg = setValueColor\r\n\r\n    if((cell.value && cell.value === highlightedNumber)){\r\n        bg = highlightedColor\r\n    }\r\n    if(cell.candidates.some(c => c === highlightedNumber)){\r\n        bg = highlightedCandidateColor\r\n    }\r\n\r\n    // Highlighted number takes precedence over selected digit highlighting\r\n    // Don't highlight selected digit if cell has highlighting already\r\n    if(!highlightedNumber){\r\n        if((cell.value && cell.value === selectedDigit) || cell.candidates.some(c => c === selectedDigit)){\r\n            bg = selectedDigitHighlightColor\r\n        }\r\n    }\r\n\r\n    if(selected) bg = selectedColor\r\n    if(hasError) bg = errorColor\r\n\r\n    return bg\r\n}\r\n\r\nconst getCandidateBackgrounds = (actors: Actor[], effects: Effect[], cell: Cell, point: Point) => {\r\n    const bgs: {[key: number]: string} = {}\r\n\r\n    actors = actors.filter(actor => pointsEqual(actor.point, point))\r\n    effects = effects.filter(eff => eff.type !== 'none' && pointsEqual(eff.point, point))\r\n\r\n    for(const actor of actors){\r\n        if(actor.cand){\r\n            bgs[actor.cand] = actorCandidateColor\r\n            if(actor.chainSet === 'yes'){\r\n                bgs[actor.cand] = actorChainCandidateYesColor\r\n            }\r\n            if(actor.chainSet === 'no'){\r\n                bgs[actor.cand] = actorChainCandidateNoColor\r\n            }\r\n        }\r\n    }\r\n\r\n    for(const eff of effects){\r\n        if(eff.type === 'elimination'){\r\n            for(let cand of eff.numbers){\r\n                bgs[cand] = eliminateCandidateColor\r\n            }\r\n        }\r\n        if(eff.type === 'value' && eff.number !== null){\r\n            bgs[eff.number] = setCandidateColor\r\n        }\r\n    }\r\n\r\n    return bgs\r\n}\r\n\r\nconst CellDisplay = (props: CellDisplayProps) => {\r\n    const {effects, actors} = props.solveResult ?? {effects: [], actors: []}\r\n    const {point, selected, affected, cell, highlightedNumber, selectedDigit, celebration, hasError} = props\r\n    const [celebrationCounter, setCelebrationCount] = React.useState(0)\r\n\r\n    React.useEffect(() => {\r\n        setCelebrationCount(0)\r\n    }, [celebration])\r\n\r\n    React.useEffect(() => {\r\n        if(celebration){\r\n            if(celebrationCounter < 100) {\r\n                setTimeout(() => {\r\n                    setCelebrationCount(celebrationCounter + 1)\r\n                }, 50)\r\n            }\r\n        }\r\n    })\r\n\r\n    let bg = React.useMemo(() =>\r\n        getCellBackgroundColor(actors, effects, point, cell, affected, selected, highlightedNumber, selectedDigit, hasError)\r\n    , [actors, effects, point, cell, affected, selected, highlightedNumber, selectedDigit, hasError])\r\n\r\n    const candBgs = React.useMemo(() =>\r\n        getCandidateBackgrounds(actors, effects, cell, point)\r\n    , [actors, effects, cell, point])\r\n\r\n    if(props.celebration){\r\n        const pointNumber = (point.y * 9 + point.x)\r\n        const pointOfHundred = Math.round((pointNumber/81)*100)\r\n        const seed = ((pointOfHundred + celebrationCounter)%100)/100\r\n        bg = darken(selectedColor, seed)\r\n    }\r\n\r\n    let style: any = {\r\n        backgroundColor: bg,\r\n        color: getContrastText(bg),\r\n        border: '1px solid',\r\n        borderColor: boardBorderColor,\r\n        display: 'flex',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n        height: '100%',\r\n        width: '100%',\r\n        lineHeight: 1\r\n    }\r\n    const {x, y} = point\r\n    const addHardBorder = (side) => {\r\n        style = {...style, ['border' + side]: '2px solid ' + boardBorderHardColor}\r\n    }\r\n    if(x % 3 === 0 && x > 0) addHardBorder('Left')\r\n    if(y % 3 === 0 && y > 0) addHardBorder('Top')\r\n    if(x === 0) addHardBorder('Left')\r\n    if(x === 8) addHardBorder('Right')\r\n    if(y === 0) addHardBorder('Top')\r\n    if(y === 8) addHardBorder('Bottom')\r\n\r\n    return (\r\n        <div style={style}>\r\n            {cell.value === null\r\n                ? <Candidates candidates={cell.candidates} bgs={candBgs} height={props.cellHeight} />\r\n                : <span style={{ fontSize: Math.floor(props.cellHeight/2) }}>{cell.value}</span>\r\n            }\r\n        </div>\r\n    )\r\n}\r\n\r\nexport type BoardDisplayProps = {\r\n    board: Board\r\n    solveResult: SolveResult | null\r\n    celebration: boolean\r\n}\r\n\r\nexport const BoardDisplay = (props: BoardDisplayProps) => {\r\n    const { board, celebration } = props\r\n    const [isSelecting, setIsSelecting] = React.useState(false)\r\n\r\n    const ref = React.useRef<HTMLDivElement | null>(null)\r\n    const [height, setHeight] = React.useState(400)\r\n    const cellHeight = height / 9\r\n\r\n    // Preserve aspect ratio of the board.\r\n    // We add an absolutely positioned div with width and height 100% to measure from.\r\n    // We calculate those percents in pixels, and set both width and height to be the smallest of the two.\r\n    React.useEffect(() => {\r\n        const setBoardHeightDom = () => {\r\n            if (ref?.current?.clientWidth && ref.current?.clientHeight) {\r\n                const currentWidth = ref.current?.clientWidth\r\n                const currentHeight = ref.current?.clientHeight\r\n                const min = Math.min(currentWidth, currentHeight)\r\n                setHeight(min)\r\n            }\r\n        }\r\n        const setHeightAndRequest = () => {\r\n            setBoardHeightDom()\r\n            window.requestAnimationFrame(setHeightAndRequest)\r\n        }\r\n\r\n        setHeightAndRequest()\r\n    }, [ref, setHeight])\r\n\r\n    const solutionBoard = useSelector(selectSolution)\r\n    const selectedCells = useSelector((state: State) => state.selectedCells)\r\n    const selectedDigit = useSelector((state: State) => state.selectedDigit)\r\n\r\n    const highlightedNumber = selectedCells.length === 1 ? board[selectedCells[0].y][selectedCells[0].x].value : null\r\n    const affectedPoints = React.useMemo(() => selectedCells.length === 1 ? getAffectedPoints(selectedCells[0]) : [], [selectedCells])\r\n\r\n    const startSelect = (point: Point, e: React.MouseEvent) => {\r\n        if(e.ctrlKey){\r\n            actions.addSelectedCell(point)\r\n        }else{\r\n            actions.setSelectedCells([point])\r\n        }\r\n        setIsSelecting(true)\r\n    }\r\n    const startSelectTouch = (point: Point) => {\r\n        actions.setSelectedCells([point])\r\n        setIsSelecting(true)\r\n    }\r\n    const addSelect = (point: Point) => {\r\n        if(isSelecting){\r\n            actions.addSelectedCell(point)\r\n        }\r\n    }\r\n    const endSelect = React.useCallback(() => {\r\n        setIsSelecting(false)\r\n    }, [])\r\n\r\n    useEventListener('mouseup', endSelect)\r\n\r\n    return (\r\n        <div\r\n            style={{\r\n                width: '100%',\r\n                height: '100%',\r\n                position: 'relative',\r\n                display: 'flex',\r\n                justifyContent: 'center'\r\n            }}\r\n        >\r\n            {/* Add a dummy div that is used to measure the current widths and heights */}\r\n            <div\r\n                ref={ref}\r\n                style={{\r\n                    width: '100%',\r\n                    height: '100%',\r\n                    position: 'absolute',\r\n                    zIndex: -1\r\n                }}\r\n            />\r\n            <div\r\n                style={{\r\n                    width: height,\r\n                    height: height,\r\n                    display: 'grid',\r\n                    gridTemplateColumns: '1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr',\r\n                    gridTemplateRows: '1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr',\r\n                    gap: 0,\r\n                }}\r\n            >\r\n                {board.flatMap((row, y) => {\r\n                    return row.map((cell, x) => {\r\n                        const id = getPointId(x, y)\r\n                        const point: Point = {x, y, id}\r\n                        const selected = selectedCells.some(p => pointsEqual(p, point))\r\n                        const affected = affectedPoints.some(p => pointsEqual(p, point))\r\n                        const hasError = !!solutionBoard && cell.value !== null && cell.value !== getBoardCell(solutionBoard, point).value\r\n\r\n                        return (\r\n                            <div\r\n                                key={id}\r\n                                data-x={x}\r\n                                data-y={y}\r\n                                className={'touchevents-suck'}\r\n                                onMouseDown={(e) => startSelect({x, y, id: getPointId(x, y)}, e)}\r\n                                onMouseOver={() => addSelect({x, y, id: getPointId(x, y)})}\r\n                                onMouseUp={endSelect}\r\n                                onTouchStart={() => startSelectTouch({x, y, id: getPointId(x, y)})}\r\n                                onTouchMove={(e) => {\r\n                                    const loc = e.touches[0]\r\n\r\n                                    const target = document.elementFromPoint(loc.clientX, loc.clientY)\r\n                                    const actualTarget = target?.closest('.touchevents-suck')\r\n\r\n                                    const xStr = actualTarget?.getAttribute('data-x')\r\n                                    const yStr = actualTarget?.getAttribute('data-y')\r\n\r\n                                    if (!(xStr && yStr)) {\r\n                                        return\r\n                                    }\r\n                                    const x = Number(xStr)\r\n                                    const y = Number(yStr)\r\n\r\n                                    addSelect({x, y, id: getPointId(x, y)})\r\n                                }}\r\n                                onTouchCancel={endSelect}\r\n                                onTouchEnd={endSelect}\r\n                                style={{\r\n                                    'WebkitTouchCallout': 'none',\r\n                                    'WebkitUserSelect': 'none',\r\n                                    'KhtmlUserSelect': 'none',\r\n                                    'MozUserSelect': 'none',\r\n                                    'msUserSelect': 'none',\r\n                                    'userSelect': 'none',\r\n                                    height: '100%',\r\n                                }}\r\n                            >\r\n                                <CellDisplay\r\n                                    cell={cell}\r\n                                    cellHeight={cellHeight}\r\n                                    selected={selected}\r\n                                    affected={affected}\r\n                                    point={point}\r\n                                    solveResult={props.solveResult}\r\n                                    highlightedNumber={highlightedNumber}\r\n                                    selectedDigit={selectedDigit}\r\n                                    hasError={hasError}\r\n                                    celebration={celebration}\r\n                                />\r\n                            </div>\r\n                        )\r\n                    })\r\n                })}\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { Board, Point, SolveResult } from '../core/types'\r\nimport * as solve from '../core/solve'\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery'\r\nimport Button from '@material-ui/core/Button'\r\nimport { actorColor, eliminationColor, setValueColor } from '../theme'\r\nimport { mobileMediaQuery } from './app'\r\n\r\nexport type SolverProps = {\r\n    board: Board\r\n    solveResult: SolveResult | null\r\n    onSolveResult: (solveResult: SolveResult | null, prevBoard: Board) => void\r\n    onPlayFromHere: () => void\r\n}\r\n\r\nconst pointToStr = (point: Point) => `r${point.y+1}c${point.x+1}`\r\n\r\nexport const Solver = (props: SolverProps) => {\r\n    const { board, solveResult, onSolveResult } = props\r\n    const [skippedTechniques, setSkippedTechniques] = React.useState<string[]>([])\r\n    const isMobile = useMediaQuery(mobileMediaQuery)\r\n\r\n    const onToggleTechnique = React.useCallback((type: string) => {\r\n        setSkippedTechniques(s => {\r\n            if(s.some(t => t === type)){\r\n                return s.filter(t => t !== type)\r\n            }else{\r\n                return [...s, type]\r\n            }\r\n        })\r\n    }, [])\r\n\r\n    const iterate = React.useCallback(() => {\r\n        let boardBeforeSolve = board\r\n        let res = solve.iterate(boardBeforeSolve)\r\n        while(res !== null && skippedTechniques.includes(res.technique)){\r\n            boardBeforeSolve = res.board\r\n            res = solve.iterate(boardBeforeSolve)\r\n        }\r\n        onSolveResult(res, boardBeforeSolve)\r\n    }, [board, skippedTechniques, onSolveResult])\r\n\r\n    return (\r\n        <div>\r\n            <h3>Solver</h3>\r\n            <div style={{ display: 'flex', justifyContent: 'center' }}>\r\n                <Button color='primary' variant='outlined' fullWidth onClick={props.onPlayFromHere}>Play from here</Button>\r\n            </div>\r\n            <br />\r\n            <div style={{ display: 'flex', justifyContent: 'center' }}>\r\n                <Button color='primary' variant='contained' fullWidth onClick={iterate}>Iterate</Button>\r\n            </div>\r\n            {solveResult && solveResult.technique !== 'done' &&\r\n            <div>\r\n                <i>Technique:</i>\r\n                <br />\r\n                {solveResult.technique}\r\n                <br />\r\n                <i>Actors:</i>\r\n                <br />\r\n                <span style={{ background: actorColor }}>&nbsp;&nbsp;</span>\r\n                {solveResult.actors.map((actor, i) => {\r\n                    return (\r\n                        <span key={i}>{' '}\r\n                            {pointToStr(actor.point)}\r\n                            {actor.cand && `[${actor.cand}]`}\r\n                            {actor.chainSet && `${actor.chainSet === 'yes' ? 'T' : 'F'}`}\r\n                        </span>\r\n                    )\r\n                })}\r\n                <br />\r\n                <i>Effects:</i>\r\n                {solveResult.effects.map((effect, i) => {\r\n                    return (\r\n                        <div key={i}>\r\n                            {effect.type === 'elimination' &&\r\n                            <div>\r\n                                <span style={{ background: eliminationColor }}>&nbsp;&nbsp;</span>\r\n                                Eliminate {effect.numbers.join(',')} from {pointToStr(effect.point)}\r\n                            </div>\r\n                            }\r\n                            {effect.type === 'value' &&\r\n                            <div>\r\n                                <span style={{ background: setValueColor }}>&nbsp;&nbsp;</span>\r\n                                Set {effect.number} at {pointToStr(effect.point)}\r\n                            </div>\r\n                            }\r\n                        </div>\r\n                    )\r\n                })}\r\n            </div>\r\n            }\r\n            {!isMobile &&\r\n            <div>\r\n                <h4>Skip techniques</h4>\r\n                <div style={{display: 'flex', flexDirection: 'column'}}>\r\n                    {solve.techniques.map(tech => {\r\n                        const skipped = skippedTechniques.some(t => t === tech.type)\r\n                        return (\r\n                            <Button\r\n                                key={tech.type}\r\n                                size='small'\r\n                                color='default'\r\n                                fullWidth={true}\r\n                                variant='outlined'\r\n                                style={{color: skipped ? 'red' : ''}}\r\n                                onClick={() => onToggleTechnique(tech.type)}\r\n                            >\r\n                                {tech.type}\r\n                            </Button>\r\n                        )\r\n                    })}\r\n                </div>\r\n            </div>\r\n            }\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { BoardMetaData } from '../core/utils/getBoardMetaData'\r\nimport Button from '@material-ui/core/Button'\r\nimport { difficulties } from '../core/solve'\r\nimport LinearProgress from '@material-ui/core/LinearProgress'\r\nimport Table from '@material-ui/core/Table'\r\nimport TableHead from '@material-ui/core/TableHead'\r\nimport TableBody from '@material-ui/core/TableBody'\r\nimport TableRow from '@material-ui/core/TableRow'\r\nimport TableCell from '@material-ui/core/TableCell'\r\nimport Typography from '@material-ui/core/Typography'\r\nimport Divider from '@material-ui/core/Divider'\r\nimport { useSelector } from 'react-redux'\r\nimport { selectPuzzles, selectUserData } from '../selectors'\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery'\r\nimport { mobileMediaQuery } from './app'\r\nimport Paper from '@material-ui/core/Paper'\r\nimport { boardBackgroundColor } from '../theme'\r\n\r\nexport type PuzzleSelectProps = {\r\n    onPuzzleSelect: (puzzle: BoardMetaData, fromProgress: boolean) => void\r\n}\r\n\r\ntype Tab = {\r\n    type: 'difficulty'\r\n    difficulty: string\r\n} | {\r\n    type: 'custom'\r\n}\r\n\r\nexport const PuzzleSelect = (props: PuzzleSelectProps) => {\r\n    const isMobile = useMediaQuery(mobileMediaQuery)\r\n    const userData = useSelector(selectUserData)\r\n    const puzzleData = useSelector(selectPuzzles)\r\n\r\n    const [selectedTab, setSelectedTab] = React.useState<Tab>({ type: 'difficulty', difficulty: 'easy' })\r\n    const [showTechniques, setShowTechniques] = React.useState(false)\r\n\r\n    const puzzles = selectedTab.type === 'custom'\r\n        ? userData.custom.sort((a, b) => new Date(a.date) > new Date(b.date) ? 1 : -1).map(c => c.meta)\r\n        : puzzleData\r\n            .filter(puzzle => puzzle.difficulty.difficulty === selectedTab.difficulty)\r\n            .sort((a, b) => a.techniques.length - b.techniques.length)\r\n\r\n    const maxNumberOfTechniques = Math.max(...puzzles.map(t => t.techniques.length))\r\n\r\n    const table = (\r\n        <Table size={'small'}>\r\n            <TableHead>\r\n                <TableRow>\r\n                    <TableCell width={10}>#</TableCell>\r\n                    <TableCell width={250}>Name</TableCell>\r\n                    <TableCell width={40} align={'left'} />\r\n                    <TableCell width={40}>Intensity</TableCell>\r\n                    <TableCell width={200} />\r\n                    <TableCell>{showTechniques && 'Techniques'}</TableCell>\r\n                </TableRow>\r\n            </TableHead>\r\n            <TableBody>\r\n                {puzzles.map((puzzle, i) => {\r\n                    const solved = userData.solved.includes(puzzle.boardData)\r\n                    const hasProgress = !!userData.progress[puzzle.boardData]\r\n                    return (\r\n                        <TableRow key={i} hover>\r\n                            <TableCell>\r\n                                {i+1}.\r\n                            </TableCell>\r\n                            <TableCell>\r\n                                {puzzle.name}\r\n                            </TableCell>\r\n                            <TableCell>\r\n                                {solved &&\r\n                                <Typography color={'primary'}>Solved!</Typography>\r\n                                }\r\n                            </TableCell>\r\n                            <TableCell>\r\n                                <LinearProgress\r\n                                    variant={'determinate'}\r\n                                    color={'secondary'}\r\n                                    value={Math.round(100 * puzzle.techniques.length / maxNumberOfTechniques)}\r\n                                />\r\n                            </TableCell>\r\n                            <TableCell>\r\n                                <Button color={'primary'} size={'small'} onClick={() => props.onPuzzleSelect(puzzle, false)} variant={'contained'}>Play</Button>\r\n                                <span> </span>\r\n                                {hasProgress &&\r\n                                <Button size={'small'} onClick={() => props.onPuzzleSelect(puzzle, true)} variant={'outlined'}>Continue</Button>\r\n                                }\r\n                            </TableCell>\r\n                            <TableCell>\r\n                                {showTechniques &&\r\n                                puzzle.techniques.join(', ')\r\n                                }\r\n                            </TableCell>\r\n                        </TableRow>\r\n                    )\r\n                })}\r\n            </TableBody>\r\n        </Table>\r\n    )\r\n\r\n    const mobileTable = (\r\n        <>\r\n            {puzzles.map((puzzle, i) => {\r\n                const solved = userData.solved.includes(puzzle.boardData)\r\n                const hasProgress = !!userData.progress[puzzle.boardData]\r\n                return (\r\n                    <Paper key={i} variant={'outlined'} style={{ padding: 16, marginBottom: 16, background: boardBackgroundColor }}>\r\n                        <div style={{ marginLeft: -16, marginRight: -16, marginTop: -16 }}>\r\n                            <LinearProgress\r\n                                variant={'determinate'}\r\n                                color={'secondary'}\r\n                                value={Math.round(100 * puzzle.techniques.length / maxNumberOfTechniques)}\r\n                            />\r\n                        </div>\r\n                        <h4>\r\n                            {puzzle.name}\r\n                        </h4>\r\n                        <div>\r\n                            {solved &&\r\n                            <Typography color={'primary'}>Solved!</Typography>\r\n                            }\r\n                        </div>\r\n\r\n                        <div>\r\n                            <Button color={'primary'} size={'small'} onClick={() => props.onPuzzleSelect(puzzle, false)} variant={'contained'}>Play</Button>\r\n                            <span> </span>\r\n                            {hasProgress &&\r\n                            <Button size={'small'} onClick={() => props.onPuzzleSelect(puzzle, true)} variant={'outlined'}>Continue</Button>\r\n                            }\r\n                        </div>\r\n                        <div>\r\n                            {showTechniques &&\r\n                            puzzle.techniques.join(', ')\r\n                            }\r\n                        </div>\r\n                    </Paper>\r\n                )\r\n            })}\r\n        </>\r\n    )\r\n\r\n    return (\r\n        <div\r\n            style={{\r\n                height: '100%',\r\n                display: 'flex',\r\n                flexDirection: 'column'\r\n            }}\r\n        >\r\n            <div style={{ marginBottom: 16 }}>\r\n                <div style={{ display: 'flex', overflowX: 'auto' }}>\r\n                    <div key={'custom'}>\r\n                        <Button\r\n                            onClick={() => setSelectedTab({ type: 'custom' })}\r\n                            disabled={selectedTab.type === 'custom'}\r\n                        >\r\n                            Custom\r\n                        </Button>\r\n                    </div>\r\n                    {difficulties.map((difficulty) => {\r\n                        return (\r\n                            <div key={difficulty}>\r\n                                <Button\r\n                                    onClick={() => setSelectedTab({ type: 'difficulty', difficulty})}\r\n                                    disabled={selectedTab.type === 'difficulty' && selectedTab.difficulty === difficulty}\r\n                                >\r\n                                    {difficulty}\r\n                                </Button>\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n                <Divider />\r\n            </div>\r\n            <div style={{ marginBottom: 16 }}>\r\n                <Button onClick={() => setShowTechniques(!showTechniques)} variant={'outlined'}>\r\n                    Show/Hide techniques required\r\n                </Button>\r\n            </div>\r\n            <div style={{ flex: '1 1 auto', minHeight: 0}}>\r\n                <div style={{ height: '100%', overflowY: 'auto'}}>\r\n                    {isMobile\r\n                        ? mobileTable\r\n                        : table\r\n                    }\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { Board } from '../core/types'\r\nimport { allCandidates, getAllPoints, getBoardCell } from '../core/utils/sudokuUtils'\r\nimport { groupBy } from '../core/utils/misc'\r\nimport {\r\n    backgroundColor, backgroundDisabledColor,\r\n    borderHardColor,\r\n    getContrastText,\r\n    selectedDigitHighlightColor\r\n} from '../theme'\r\n\r\ntype DigitProps = {\r\n    digit: number\r\n    finished: boolean\r\n    selected: boolean\r\n    onClick: () => void\r\n}\r\n\r\nconst DigitCircle = (props: DigitProps) => {\r\n    let bgColor = backgroundColor\r\n    if(props.finished) bgColor = backgroundDisabledColor\r\n    if(props.selected) bgColor = selectedDigitHighlightColor\r\n    return (\r\n        <button\r\n            onClick={props.onClick}\r\n            style={{\r\n                backgroundColor: bgColor,\r\n                color: getContrastText(bgColor),\r\n                border: '1px solid',\r\n                borderColor: borderHardColor,\r\n                padding: 4,\r\n                font: 'inherit',\r\n                cursor: 'pointer',\r\n                outline: 'inherit',\r\n\r\n                borderRadius: '50%',\r\n                height: 35,\r\n                width: 35,\r\n                margin: 0,\r\n            }}\r\n        >\r\n            {props.digit}\r\n        </button>\r\n    )\r\n}\r\n\r\ntype DigitSelectorProps = {\r\n    board: Board\r\n    onClickDigit: (digit: number) => void\r\n    selectedDigit: number | null\r\n}\r\n\r\nconst getFinishedDigits = (board: Board): number[] => {\r\n    const digits = getAllPoints()\r\n        .map(point => getBoardCell(board, point).value)\r\n        .filter(value => value !== null)\r\n\r\n    return Object.entries(groupBy(digits, (d) => d))\r\n        .filter(([digit, list]) => list.length === 9)\r\n        .map(([digit]) => Number(digit))\r\n}\r\n\r\nexport const DigitSelector = (props: DigitSelectorProps) => {\r\n    const board = props.board\r\n    const selectedDigit = props.selectedDigit\r\n    const finishedDigits = React.useMemo(() => getFinishedDigits(board), [board])\r\n\r\n    return (\r\n      <div\r\n        style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', flexWrap: 'wrap' }}\r\n      >\r\n        {allCandidates.map(digit => {\r\n            return (\r\n                <div style={{ paddingRight: 4 }} key={digit}>\r\n                    <DigitCircle\r\n                        digit={digit}\r\n                        finished={finishedDigits.includes(digit)}\r\n                        selected={selectedDigit === digit}\r\n                        onClick={() => props.onClickDigit(digit)}\r\n                    />\r\n                </div>\r\n            )\r\n        })}\r\n      </div>\r\n    )\r\n}","import React from 'react'\r\nimport Accordion from '@material-ui/core/Accordion'\r\nimport AccordionDetails from '@material-ui/core/AccordionDetails'\r\nimport AccordionSummary from '@material-ui/core/AccordionSummary'\r\nimport Typography from '@material-ui/core/Typography'\r\nimport Divider from '@material-ui/core/Divider'\r\n\r\nconst basic = `\r\nThe basic rules of sudoku are:\r\nThe digits 1-9 must occur once in each row, column, and box.\r\n`\r\n\r\nconst fullHouse = `\r\nA house in sudoku is a row, column, or box. \r\nWhen there is only one candidate left in a house, you have a full house. \r\nJust place the last candidate.\r\n`\r\n\r\nconst hiddenSingle = `\r\nIf a candidate can only go in one cell in a house, and there are still other possible candidates for this cell, it's called a hidden single.\r\nThis is an easy technique, especially with highlighting, since the candidate can only go in one cell. \r\n`\r\n\r\nconst nakedSingle = `\r\nA naked single is when a cell can only contain one candidate. \r\nA full house is also a naked single, but we differentiate between the two because proper naked singles are harder to find.\r\nThe reason they may be hard to find is that the same candidate can still be possible in other cells in the house.\r\nIn some cases it can be really tricky to find, but most often it's fairly easy.\r\n`\r\n\r\nconst pointer = `\r\nA pointer is when all of a candidate in a box occur on the same line (row or column).\r\nThe candidate can be eliminated from the rest of the line outside the box.\r\n`\r\n\r\nconst inversePointer = `\r\nAn inverse pointer is when all of a candidate on a line is within the same box.\r\nThe candidate can be eliminated from the rest of the box.\r\n`\r\n\r\nconst nakedPair = `\r\nA naked pair is when 2 candidates occur in 2 cells of a house, and there are no other candidates in these cells.\r\nThe 2 candidates can be eliminated from the rest of the house.\r\nThe same logic applies for 3 and 4 candidates in 3 or 4 cells.   \r\n`\r\n\r\nconst hiddenPair = `\r\nA hidden pair is when the only location for 2 candidates in a house is in the same 2 cells.\r\nThe rest of the candidates in these two cells can be eliminated. The same logic applies for 3 and 4 candidates in 3 or 4 cells.\r\n\r\nYou can spot hidden pairs by looking at each candidate and see if it's represented in only two cells in a house.\r\nCheck the house to see if there is a second candidate in those cells as well. Can be quite tricky to spot.\r\n`\r\n\r\nconst xWing = `\r\nAn x-wing looks like the four corners of a rectangle. The same candidate is in each corner.\r\nThe requirement is that either both rows or both columns has the candidate in only the corners.\r\n\r\nIf both rows, the candidate can be eliminated from the columns.\r\nIf both columns, the candidate can be eliminated from the rows.\r\n\r\nA more difficult versions exist for when there is 3 rows/cols, called swordfish.\r\nIn that case, all points don't need the candidate for it work. \r\nThe only requirement is that all cells has the candidate in the same 3 rows and 3 columns,\r\nand that either all 3 rows has the candidate in only the three columns, or vice versa.\r\n\r\nIf that wasn't hard enough, there is also a jellyfish with 4 rows/cols as well.\r\n\r\nTo spot these, use highlighting :) x-wings are pretty easy to find, while swordfish and jellyfish is pretty hard.\r\n`\r\n\r\nconst swordfish = `\r\nSee x-wing\r\n`\r\n\r\nconst jellyfish = `\r\nSee x-wing\r\n`\r\n\r\nconst skyscraper = `\r\nSee x-wing first. A skyscraper is almost the same, except that one corner is not aligned on a row/col.\r\nThe row/col that is aligned can still be used to deduce that one of the cells that are not aligned must have the candidate.\r\nIf these two cells has any overlap in the cells they affect, the candidate can be eliminated from those cells.\r\nTo spot these, look for almost-x-wings.\r\n`\r\n\r\nconst uniqueRectangle = `\r\nThere are many types of unique rectangles, but the easiest one to spot is when you have a naked pair in a row,\r\nand another naked pair in a col, where one of the cells overlap. This forms an L-shape of cells with the same two candidates.\r\nTo form a rectangle, we need the last corner. In this corner, the two candidates can be eliminated.\r\nWhy? Because otherwise the sudoku cannot be unique, and all sudokus must be unique. \r\nYou'll just have to stare at this for a while to convince yourself it's true\r\n\r\nTo spot it, look for a naked pair in a row or col. Now look for a second pair originating from this pair.\r\n`\r\n\r\nconst emptyRectangle = `\r\nThe name empty rectangle can be confusing, so let's just explain the technique instead of the name.\r\n\r\nLook at a candidate in a box. If it forms an L-shape, we have a possible empty rectangle. (Tip: 2 cells are always L-shaped).\r\nNow look at the same candidate outside the box. Can you find a row or column where there are only two possible cells for this candidate?\r\nIf so, check if one of those eliminates an entire leg of the L-shape if set. If it does, the result will be a pointer.\r\nNow check the other cell in the row/col. If this cell \"sees\" the same cells as the pointer, the candidate can be eliminated from those cells.\r\n`\r\n\r\nconst xyWing = `\r\n\r\n`\r\n\r\nconst xyzWing = `\r\n\r\n`\r\n\r\nconst remotePairChain = `\r\nFill in all candidates. \r\nFind all cells with only two candidates. \r\nThe two candidates must be the same for all cells in the chain, hence \"remote pair\".\r\nPick a cell. \r\n\r\nNow start by saying to yourself \"candidate A is not true\". Look at the connected cells with the same two candidates you found earlier.\r\nPick one, and say to yourself \"candidate A is true\". Now continue alternating between these two for each cell you visit.\r\n\r\nIf at any point you say that the candidate is true, you can check if the cell \"sees\" the same cells as the cell you started with.\r\nIf so, both candidates can be eliminated from those cells.\r\n\r\nWhy? You started by saying A is NOT true, and ended by saying A IS true. Now if start by saying it IS true, the starting cell is true.\r\nSo the conclusion is that the candidate is either in the starting cell or the ending cell. \r\n`\r\n\r\nconst xChain = `\r\nFill in all candidates. \r\nLook at only one candidate. \r\nPick a cell with the candidate.\r\n \r\nStart by saying to yourself \"the candidate is NOT true\". Now look at cells affect by this cell.\r\nIf removing the candidate from the starting cell leads to the candidate being set in a different cell, \r\ngo to that cell and say \"the candidate IS true\". Now continue like this, alternating between true and not true.\r\n\r\nIf at any point you say that the candidate is true, you can check if the cell \"sees\" the same cells as the cell you started with.\r\nIf so, the candidate can be eliminated from those cells.\r\n\r\nWhy? You started by saying the candidate was not true. That lead to the ending cell being true.\r\nThe alternative was that the starting cell WAS true. So either the starting cell is true, or the ending cell is true.\r\n`\r\n\r\nconst xyChain = `\r\nSee xChain.\r\n\r\nFill in all candidates. \r\nLook at only cells with two possible candidates. \r\nPick a cell.\r\n\r\nStart by saying to yourself, \"candidate A is NOT true\". Now follow the chain, alternating true/not true. \r\nIf you end up on a cell where the candidate is the same as the starting candidate, and is true, check for cells that \"sees\" both the start and the end.\r\nThe candidate can be eliminated from these points. \r\n`\r\n\r\nconst techniqueDescriptions = {\r\n    basic,\r\n    fullHouse,\r\n    hiddenSingle,\r\n    nakedSingle,\r\n    pointer,\r\n    inversePointer,\r\n    nakedPair,\r\n    hiddenPair,\r\n    xWing,\r\n    swordfish,\r\n    jellyfish,\r\n    skyscraper,\r\n    uniqueRectangle,\r\n    emptyRectangle,\r\n    xyWing,\r\n    xyzWing,\r\n    remotePairChain,\r\n    xChain,\r\n    xyChain\r\n}\r\n\r\nexport const Help = (props) => {\r\n    return (\r\n        <div>\r\n            <h3>Techniques</h3>\r\n            <Divider />\r\n            <Typography>\r\n                Below you'll find some short descriptions and hints for each technique.<br />\r\n                If you want more detailed explanations with examples, I recommend the excellent guide over at\r\n\r\n                <a href='http://hodoku.sourceforge.net/en/techniques.php' target='_blank' rel=\"noopener noreferrer\" style={{ color: 'lightblue' }}>\r\n                    <span> HoDoKu</span>\r\n                </a>\r\n            </Typography>\r\n            <br />\r\n\r\n            {Object.entries(techniqueDescriptions).map(([name, d]) => {\r\n                return (\r\n                    <Accordion>\r\n                        <AccordionSummary>{name}</AccordionSummary>\r\n                        <AccordionDetails>\r\n                            <Typography>{d.trim().split(/\\r\\n|\\n/g).map(line => (<>{line}<br/></>))}</Typography>\r\n                        </AccordionDetails>\r\n                    </Accordion>\r\n                )\r\n            })}\r\n        </div>\r\n    )\r\n}","import { Board } from '../types'\r\nimport { canPutDigit, cloneBoard, getPointId } from './sudokuUtils'\r\n\r\nexport const hasUniqueSolution = (board: Board) => {\r\n    board = cloneBoard(board)\r\n    const count = getSolutionCount(board)\r\n    return count === 1\r\n}\r\n\r\nconst getSolutionCount = (board: Board, x = 0, y = 0) => {\r\n    if(x === 9){\r\n        x = 0\r\n        y++\r\n        if(y === 9){\r\n            return 1 // Got to the end of the board, solution found\r\n        }\r\n    }\r\n    if(board[y][x].value !== null){\r\n        return getSolutionCount(board, x+1, y)\r\n    }\r\n\r\n    let count = 0\r\n    for(let n = 1; n <= 9; n++){\r\n        if(canPutDigit(board, {x, y, id: getPointId(x, y)}, n)){\r\n            board[y][x].value = n\r\n            count += getSolutionCount(board, x+1,y)\r\n            if(count >= 2){\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    board[y][x].value = null\r\n    return count\r\n}","const adjectives = {\r\n    beginner: [\r\n        'tame',\r\n        'friendly',\r\n        'hopeful',\r\n        'brief',\r\n        'lucky',\r\n        'blissful',\r\n        'adorable'\r\n    ],\r\n    easy: [\r\n        'nice',\r\n        'well meaning',\r\n        'agreeable',\r\n        'calm',\r\n        'careless',\r\n        'relaxed',\r\n        'breathless',\r\n        'cute'\r\n    ],\r\n    medium: [\r\n        'aspiring',\r\n        'cheerful',\r\n        'cooperative',\r\n        'eager',\r\n        'capable',\r\n        'secretive',\r\n        'lovely',\r\n        'speedy',\r\n    ],\r\n    hard: [\r\n        'bold',\r\n        'fierce',\r\n        'modern',\r\n        'bountiful',\r\n        'courageous',\r\n        'brainy',\r\n        'alluring',\r\n        'careful'\r\n    ],\r\n    expert: [\r\n        'murky',\r\n        'strange',\r\n        'crooked',\r\n        'outstanding',\r\n        'fearless',\r\n        'passionate',\r\n        'outrageous',\r\n        'mysterious',\r\n        'sizable'\r\n    ],\r\n    artisan: [\r\n        'artisanal',\r\n        'futuristic',\r\n        'irregular',\r\n        'defiant',\r\n        'determined',\r\n        'diligent',\r\n        'cumbersome',\r\n        'majestic'\r\n    ],\r\n    master: [\r\n        'vast',\r\n        'great',\r\n        'masterful',\r\n        'eternal',\r\n        'astronomical',\r\n        'enchanting',\r\n        'erratic',\r\n        'massive'\r\n    ],\r\n    jedi: [\r\n        'incredulous',\r\n        'forceful',\r\n        'ominous',\r\n        'immense',\r\n        'combative',\r\n        'disastrous',\r\n        'ruthless'\r\n    ]\r\n}\r\n\r\nconst subject = {\r\n    beginner: [\r\n        'teddy bear',\r\n        'child',\r\n        'companion',\r\n        'old lady',\r\n        'gungan',\r\n        'disney character',\r\n        'mouse',\r\n        'cat'\r\n    ],\r\n    easy: [\r\n        'neighbor',\r\n        'friend',\r\n        'farm animal',\r\n        'pokemon',\r\n        'dog',\r\n        'musician',\r\n        'coffee cup',\r\n        'soda bottle'\r\n    ],\r\n    medium: [\r\n        'colleague',\r\n        'buddy',\r\n        'do-gooder',\r\n        'rain forrest',\r\n        'orangutan',\r\n        'meerkat',\r\n        'swimming pool',\r\n        'loud speaker',\r\n    ],\r\n    hard: [\r\n        'candidate',\r\n        'middle manager',\r\n        'gang member',\r\n        'entrance',\r\n        'columns',\r\n        'vessel',\r\n        'vehicle',\r\n        'lion',\r\n        'elephant',\r\n    ],\r\n    expert: [\r\n        'skyscraper',\r\n        'sea creature',\r\n        'board of executives',\r\n        'stadium',\r\n        'detective',\r\n        'commission',\r\n        'adventure',\r\n        'legend'\r\n    ],\r\n    artisan: [\r\n        'sea monster',\r\n        'executive officer',\r\n        'admiral',\r\n        'hydrogen blimp',\r\n        'president',\r\n        'warden',\r\n        'alien',\r\n        'space ship'\r\n    ],\r\n    master: [\r\n        'mountain',\r\n        'ocean',\r\n        'volcano',\r\n        'earthquake',\r\n        'tsunami',\r\n        'avalanche',\r\n        'erruption',\r\n        'prisoner'\r\n    ],\r\n    jedi: [\r\n        'sith lord',\r\n        'universe',\r\n        'solar system',\r\n        'galaxy',\r\n        'solar storm',\r\n        'super nova',\r\n        'black hole'\r\n    ]\r\n}\r\n\r\nconst rand = (n: number) => Math.floor((Math.random()*n))\r\n\r\nexport const generateName = (difficulty: string) => {\r\n    return [\r\n        adjectives[difficulty][rand(adjectives[difficulty].length)],\r\n        subject[difficulty][rand(subject[difficulty].length)],\r\n    ].join(' ')\r\n}","import { Board } from '../types'\r\nimport { getOverallDifficulty, getTechniquesRequiredForSolvingBoard } from '../solve'\r\nimport { prepareBoardForSolver } from '../sudoku'\r\nimport { generateName } from './generateName'\r\n\r\nexport type BoardMetaData = {\r\n    name: string\r\n    techniques: string[]\r\n    difficulty: {\r\n        level: number\r\n        difficulty: string\r\n    }\r\n    givens: number\r\n    boardData: string\r\n}\r\n\r\nexport const getBoardMetaData = (board: Board): BoardMetaData => {\r\n    board = prepareBoardForSolver(board)\r\n    const techniques = getTechniquesRequiredForSolvingBoard(board)\r\n    const difficulty = getOverallDifficulty(techniques)\r\n    let givens = 0\r\n    let boardData = ''\r\n    for(let y = 0; y < 9; y++){\r\n        for(let x = 0; x < 9; x++){\r\n            const cell = board[y][x]\r\n            boardData += cell.value === null ? '0' : String(cell.value)\r\n            if(cell.given){\r\n                givens++\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        name: generateName(difficulty.difficulty),\r\n        techniques,\r\n        difficulty,\r\n        givens,\r\n        boardData\r\n    }\r\n}","import React from 'react'\r\nimport { useDropzone } from 'react-dropzone'\r\nimport { boardBackgroundColor } from '../theme'\r\nimport TextField from '@material-ui/core/TextField'\r\nimport Button from '@material-ui/core/Button'\r\nimport { hasUniqueSolution } from '../core/utils/hasUniqueSolution'\r\nimport { boardFromStr } from '../core/sudoku'\r\nimport { getBoardMetaData } from '../core/utils/getBoardMetaData'\r\nimport { actions } from '../index'\r\nimport { UserData } from '../state'\r\nimport { unique, uniqueBy } from '../core/utils/misc'\r\nimport { useSelector } from 'react-redux'\r\nimport { selectUserData } from '../selectors'\r\nimport format from 'date-fns/format'\r\n\r\nexport type ImportExportProps = {}\r\n\r\nconst looksLikeUserData = (obj: any) => {\r\n    return Array.isArray(obj.solved) && obj.progress && Array.isArray(obj.custom)\r\n}\r\n\r\nconst downloadJsonStr = (text, fileName) => {\r\n    const fileType = 'application/json'\r\n    const blob = new Blob([text], { type: fileType })\r\n    const a = document.createElement('a')\r\n    a.download = fileName\r\n    a.href = URL.createObjectURL(blob)\r\n    a.dataset.downloadurl = [fileType, a.download, a.href].join(':')\r\n    a.style.display = 'none'\r\n    document.body.appendChild(a)\r\n    a.click()\r\n    document.body.removeChild(a)\r\n    setTimeout(() => URL.revokeObjectURL(a.href), 1500)\r\n}\r\n\r\nconst mergeUserData = (oldData: UserData, newData: Partial<UserData>) => {\r\n    return {\r\n        solved: unique([...(newData.solved ?? []), ...oldData.solved]),\r\n        progress: {...oldData.progress, ...newData.progress},\r\n        custom: uniqueBy([...(newData.custom ?? []), ...oldData.custom], (a, b) => a.meta?.boardData === b.meta?.boardData)\r\n    }\r\n}\r\n\r\nexport const ImportExport = (props: ImportExportProps) => {\r\n    const userData = useSelector(selectUserData)\r\n    const [importState, setImportState] = React.useState<string | null>(null)\r\n    const [importBoardStr, setImportBoardStr] = React.useState('')\r\n    const [boardStrValidation, setBoardStrValidation] = React.useState<string | null>(null)\r\n\r\n    const onImport = React.useCallback((str: string) => {\r\n        try{\r\n            const obj = JSON.parse(str)\r\n            if (looksLikeUserData(obj)) {\r\n                const newUserData = mergeUserData(userData, obj)\r\n                actions.setUserData(newUserData)\r\n                setImportState('Import successful!')\r\n                return\r\n            }\r\n        }catch(err){}\r\n\r\n        setImportState('Failed to import. Please check that the save file was exported from this app.')\r\n    }, [userData])\r\n\r\n    const onImportBoardStr = React.useCallback(() => {\r\n        const str = importBoardStr.trim()\r\n        if (str.length !== 81) {\r\n            setBoardStrValidation('Board must be 81 characters long')\r\n            return\r\n        }\r\n        const board = boardFromStr(str)\r\n        if (!hasUniqueSolution(board)) {\r\n            setBoardStrValidation('That sudoku is not unique')\r\n            return\r\n        }\r\n        const meta = getBoardMetaData(board)\r\n        const newUserData = mergeUserData(userData, {\r\n            custom: [{ meta, date: new Date().toISOString() }]\r\n        })\r\n        actions.setUserData(newUserData)\r\n        setBoardStrValidation('Import successful! Go to puzzle select to play the imported sudoku')\r\n    }, [importBoardStr, userData])\r\n\r\n    const onExport = React.useCallback(() => {\r\n        const time = format(new Date(), 'yyyyMMdd')\r\n        downloadJsonStr(JSON.stringify(userData, null, 2), `sudoku_${time}.json`)\r\n    }, [userData])\r\n\r\n    const onDrop = React.useCallback((acceptedFiles) => {\r\n        if (acceptedFiles.length === 0) {\r\n            return\r\n        }\r\n        const file = acceptedFiles[0]\r\n\r\n        const reader = new FileReader()\r\n        reader.onload = () => onImport(reader.result as string)\r\n        reader.readAsText(file)\r\n    }, [onImport])\r\n\r\n    const {getRootProps, getInputProps} = useDropzone({onDrop, maxFiles: 1})\r\n\r\n    return (\r\n        <div>\r\n            <h3>Import custom board</h3>\r\n\r\n            <TextField\r\n                type={'text'}\r\n                value={importBoardStr}\r\n                onChange={e => setImportBoardStr(e.target.value)}\r\n                fullWidth\r\n                variant={'outlined'}\r\n                placeholder={'Paste board string here (ex. 200030967400...)'}\r\n            />\r\n            {boardStrValidation !== null && boardStrValidation}\r\n            <br />\r\n            <Button\r\n                color={'primary'}\r\n                variant={'contained'}\r\n                onClick={onImportBoardStr}\r\n            >\r\n                Import\r\n            </Button>\r\n\r\n            <h3>Import save data</h3>\r\n\r\n            <div\r\n                {...getRootProps()}\r\n                style={{\r\n                    width: '100%',\r\n                    height: 200,\r\n                    display: 'flex',\r\n                    justifyContent: 'center',\r\n                    alignItems: 'center',\r\n                    background: boardBackgroundColor\r\n                }}\r\n            >\r\n                <input {...getInputProps()} />\r\n                <div>Drag a save file here, or click to select file</div>\r\n            </div>\r\n            {importState !== null && importState}\r\n\r\n            <h3>Export save data</h3>\r\n\r\n            <Button\r\n                color={'primary'}\r\n                variant={'contained'}\r\n                onClick={onExport}\r\n            >\r\n                Export\r\n            </Button>\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { useSelector } from 'react-redux'\r\nimport { selectHints } from '../selectors'\r\n\r\nexport const Hints = (props) => {\r\n    const hints = useSelector(selectHints)\r\n\r\n    return (\r\n        <div>\r\n            <h3>Hints</h3>\r\n            <p>If all candidates are placed in the current board, the following techniques are required to get the next digit</p>\r\n            <ul>\r\n                {hints.map((t, i) => <li key={i}>{t}</li>)}\r\n            </ul>\r\n        </div>\r\n    )\r\n}","import React from 'react'\r\nimport { BoardDisplay } from './board'\r\nimport { Solver } from './solver'\r\nimport { Point } from '../core/types'\r\nimport { boardFromStr } from '../core/sudoku'\r\nimport useEventListener from '@use-it/event-listener'\r\nimport Paper from '@material-ui/core/Paper'\r\nimport Button from '@material-ui/core/Button'\r\nimport { PuzzleSelect } from './puzzle-select'\r\nimport useMediaQuery  from '@material-ui/core/useMediaQuery'\r\nimport Dialog from '@material-ui/core/Dialog'\r\nimport { DigitSelector } from './digit-selector'\r\nimport { Help } from './help'\r\nimport { ImportExport } from './import-export'\r\nimport { useSelector } from 'react-redux'\r\nimport { selectHasError, selectIsComplete, selectSolution } from '../selectors'\r\nimport { actions } from '../index'\r\nimport { Hints } from './hints'\r\nimport { State } from '../state'\r\nimport { getContrastText, setValueColor } from '../theme'\r\n\r\nexport const mobileMediaQuery = '(max-width:960px)'\r\n\r\nconst dummyBoard = boardFromStr('000000000000000000000000000000000000000000000000000000000000000000000000000000000')\r\n\r\nexport function App(){\r\n    const [hintsOpen, setHintsOpen] = React.useState(false)\r\n    const [puzzleSelectOpen, setPuzzleSelectOpen] = React.useState(false)\r\n    const [importExportOpen, setImportExportOpen] = React.useState(false)\r\n    const [helpOpen, setHelpOpen] = React.useState(false)\r\n    const isMobile = useMediaQuery(mobileMediaQuery)\r\n\r\n    const inputMode = useSelector((state: State) => state.inputMode)\r\n    const solverState = useSelector((state: State) => state.game?.solver ?? null)\r\n    const boardStack = useSelector((state: State) => state.game?.boardStack ?? [])\r\n    const selectedCells = useSelector((state: State) => state.selectedCells)\r\n    const selectedDigit = useSelector((state: State) => state.selectedDigit)\r\n    const board = useSelector((state: State) => state.game?.board ?? dummyBoard)\r\n    const boardMetaData = useSelector((state: State) => state.game?.boardMetaData ?? null)\r\n\r\n    const solutionBoard = useSelector(selectSolution)\r\n    const isComplete = useSelector(selectIsComplete)\r\n    const hasError = useSelector(selectHasError)\r\n\r\n    const toggleSolver = React.useCallback(() => {\r\n        actions.toggleSolver(solutionBoard)\r\n    }, [solutionBoard])\r\n\r\n    const toggleHints = React.useCallback(() => {\r\n        setHintsOpen(x => !x)\r\n    }, [])\r\n\r\n    const onSetDigit = React.useCallback((digit: number, points: Point[]) => {\r\n        actions.setDigit(digit, points, solutionBoard)\r\n    }, [solutionBoard])\r\n\r\n    const onSelectDigit = React.useCallback((digit: number) => {\r\n        if (isMobile && selectedCells.length > 0) {\r\n            actions.setDigit(digit, selectedCells, solutionBoard)\r\n        } else {\r\n            actions.selectDigit(digit)\r\n        }\r\n    }, [isMobile, selectedCells, solutionBoard])\r\n\r\n    const clearSelected = React.useCallback(() => {\r\n        actions.setSelectedCells([])\r\n    }, [])\r\n\r\n    const onGlobalKeyDown = React.useCallback((e: KeyboardEvent) => {\r\n        if(e.key.toLowerCase() === 'a') actions.setInputMode('value')\r\n        if(e.key.toLowerCase() === 's') actions.setInputMode('candidates')\r\n        if(e.key.toLowerCase() === 'n') actions.undo()\r\n        if(e.key.toLowerCase() === 'c') toggleSolver()\r\n        if(e.key.toLowerCase() === 'h') toggleHints()\r\n        if(e.key.toLowerCase() === 'd') clearSelected()\r\n        if(/\\d/.test(e.key)){\r\n            const number = parseInt(e.key, 10)\r\n            if(number >= 1 && number <= 9){\r\n                if(selectedCells.length > 0){\r\n                    onSetDigit(number, selectedCells)\r\n                }else{\r\n                    onSelectDigit(number)\r\n                }\r\n            }\r\n        }\r\n    }, [toggleSolver, toggleHints, onSetDigit, selectedCells, clearSelected, onSelectDigit])\r\n\r\n    useEventListener('keydown', onGlobalKeyDown)\r\n\r\n    return (\r\n        <div style={{ height: '100%', minHeight: 0, display: 'flex', justifyContent: 'center' }}>\r\n            <div style={{ height: '100%', width: '100%', padding: isMobile ? 0 : 16, maxWidth: 800 }}>\r\n                <div style={{ height: '100%', display: 'flex', flexDirection: 'column', alignItems: 'stretch' }}>\r\n                    <Paper style={{ padding: 16, marginBottom: 16 }}>\r\n                        <div style={{ display: 'flex' }}>\r\n                            <div style={{ marginRight: 16 }}>\r\n                                <Button color='primary' variant='contained' onClick={() => setPuzzleSelectOpen(true)}>\r\n                                    Select puzzle\r\n                                </Button>\r\n                            </div>\r\n                            <div>\r\n                                <Button color='secondary' variant='contained' onClick={() => setImportExportOpen(true)}>\r\n                                    Import / Export\r\n                                </Button>\r\n                            </div>\r\n                            <div style={{ flex: 1, display: 'flex', justifyContent: 'flex-end' }}>\r\n                                <Button variant={'outlined'} onClick={() => setHelpOpen(true)}>\r\n                                    Help\r\n                                </Button>\r\n                            </div>\r\n                        </div>\r\n                    </Paper>\r\n                    <Paper style={{ padding: 16, paddingLeft: isMobile ? 4 : 16, paddingRight: isMobile ? 4 : 16, flex: '1 1 auto', minHeight: 0, display: 'flex', flexDirection: 'column' }}>\r\n                        {boardMetaData &&\r\n                        <div style={{ display: 'flex', justifyContent: 'center', paddingBottom: 16 }}>\r\n                            <h4 style={{ margin: 0 }}>Puzzle: {boardMetaData.name} - Difficulty: {boardMetaData.difficulty.difficulty}</h4>\r\n                        </div>\r\n                        }\r\n                        <div style={{ flex: '1 1 auto', minHeight: 0, display: 'flex', justifyContent: 'center' }}>\r\n                            <BoardDisplay\r\n                                board={solverState ? solverState.boardBeforeSolve : board}\r\n                                solveResult={solverState?.solveResult ?? null}\r\n                                celebration={isComplete && !hasError}\r\n                            />\r\n                        </div>\r\n                        <div style={{ display: 'flex', justifyContent: 'center', flexWrap: 'wrap', paddingBottom: 16 }}>\r\n                            <Button\r\n                                onClick={() => actions.setInputMode('value')}\r\n                                disabled={inputMode === 'value'}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                                style={{\r\n                                    ...inputMode === 'value'\r\n                                        ? {\r\n                                            backgroundColor: setValueColor,\r\n                                            color: getContrastText(setValueColor)\r\n                                        } : undefined,\r\n                                }}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Digit'\r\n                                    : 'Digit (a)'\r\n                                }\r\n                            </Button>\r\n                            <Button\r\n                                onClick={() => actions.setInputMode('candidates')}\r\n                                disabled={inputMode === 'candidates'}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                                style={{\r\n                                    ...inputMode === 'candidates'\r\n                                        ? {\r\n                                            backgroundColor: setValueColor,\r\n                                            color: getContrastText(setValueColor)\r\n                                        } : undefined,\r\n                                }}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Candidate'\r\n                                    : 'Candidate (s)'\r\n                                }\r\n                            </Button>\r\n                            <Button\r\n                                onClick={actions.undo}\r\n                                disabled={boardStack.length === 0}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Undo'\r\n                                    : 'Undo (n)'\r\n                                }\r\n                            </Button>\r\n                            <Button\r\n                                onClick={clearSelected}\r\n                                disabled={selectedCells.length === 0}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Deselect all'\r\n                                    : 'Deselect all (d)'\r\n                                }\r\n                            </Button>\r\n                            <Button\r\n                                onClick={toggleHints}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                                style={{\r\n                                    ...hintsOpen\r\n                                        ? {\r\n                                            backgroundColor: setValueColor,\r\n                                            color: getContrastText(setValueColor)\r\n                                        } : undefined,\r\n                                }}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Hints'\r\n                                    : 'Hints (h)'\r\n                                }\r\n                            </Button>\r\n                            <Button\r\n                                onClick={toggleSolver}\r\n                                disabled={hasError ?? false}\r\n                                variant={'outlined'}\r\n                                size={'small'}\r\n                                style={{\r\n                                    ...!!solverState\r\n                                        ? {\r\n                                            backgroundColor: setValueColor,\r\n                                            color: getContrastText(setValueColor)\r\n                                        } : undefined,\r\n                                }}\r\n                            >\r\n                                {isMobile\r\n                                    ? 'Solver'\r\n                                    : 'Solver (c)'\r\n                                }\r\n                            </Button>\r\n                        </div>\r\n                        <div>\r\n                            <DigitSelector\r\n                                board={board}\r\n                                onClickDigit={onSelectDigit}\r\n                                selectedDigit={selectedDigit}\r\n                            />\r\n                        </div>\r\n                    </Paper>\r\n                </div>\r\n            </div>\r\n            {hintsOpen &&\r\n            <Paper\r\n                style={{\r\n                    height: '100%',\r\n                    width: 300,\r\n                    padding: 16,\r\n                    marginRight: 16,\r\n                    overflowY: 'auto',\r\n                    ...isMobile\r\n                        ? {\r\n                            position: 'absolute',\r\n                            height: 'auto',\r\n                            width: 'auto',\r\n                            margin: 16,\r\n                            right: 0\r\n                        } : {}\r\n                }}\r\n            >\r\n                <Hints />\r\n                {isMobile &&\r\n                    <Button variant={'outlined'} onClick={toggleHints}>Close</Button>\r\n                }\r\n            </Paper>\r\n            }\r\n            {!!solverState &&\r\n            <Paper\r\n                style={{\r\n                    height: '100%',\r\n                    width: 300,\r\n                    padding: 16,\r\n                    overflowY: 'auto',\r\n                    ...isMobile\r\n                        ? {\r\n                            position: 'absolute',\r\n                            height: 'auto',\r\n                            width: 'auto',\r\n                            margin: 0,\r\n                            right: 0,\r\n                            opacity: '80%'\r\n                        } : {}\r\n                }}\r\n            >\r\n                <Solver\r\n                    board={solverState.solveResult?.board ?? solverState.boardBeforeSolve}\r\n                    solveResult={solverState.solveResult}\r\n                    onSolveResult={actions.setSolveResult}\r\n                    onPlayFromHere={actions.playFromSolver}\r\n                />\r\n            </Paper>\r\n            }\r\n            <Dialog\r\n                fullWidth\r\n                maxWidth={isMobile ? 'sm' : 'lg'}\r\n                open={puzzleSelectOpen}\r\n                onClose={() => setPuzzleSelectOpen(false)}\r\n            >\r\n                <Paper style={{ padding: 16 }}>\r\n                    <PuzzleSelect\r\n                        onPuzzleSelect={(puzzle, fromProgress) => {\r\n                            actions.startPuzzle(puzzle, fromProgress)\r\n                            setPuzzleSelectOpen(false)\r\n                        }}\r\n                    />\r\n                </Paper>\r\n            </Dialog>\r\n            <Dialog\r\n                fullWidth\r\n                maxWidth={isMobile ? 'sm' : 'md'}\r\n                open={helpOpen}\r\n                onClose={() => setHelpOpen(false)}\r\n            >\r\n                <Paper style={{ padding: 16 }}>\r\n                    <Help />\r\n                </Paper>\r\n            </Dialog>\r\n            <Dialog\r\n                fullWidth\r\n                maxWidth={isMobile ? 'sm' : 'md'}\r\n                open={importExportOpen}\r\n                onClose={() => setImportExportOpen(false)}\r\n            >\r\n                <Paper style={{ padding: 16 }}>\r\n                    <ImportExport />\r\n                </Paper>\r\n            </Dialog>\r\n        </div>\r\n    )\r\n}","import { Board, InputMode, Point, SolveResult } from './core/types'\r\nimport { BoardMetaData } from './core/utils/getBoardMetaData'\r\nimport { applyInputValue, boardFromStr, boardToStr, prepareBoardForSolver } from './core/sudoku'\r\nimport { boardHasError, boardIsComplete, pointsEqual } from './core/utils/sudokuUtils'\r\nimport { uniqueBy } from './core/utils/misc'\r\n\r\nexport type UserData = {\r\n    solved: string[]\r\n    custom: {\r\n        meta: BoardMetaData\r\n        date: string\r\n    }[]\r\n    progress: {\r\n        [key: string]: Board\r\n    }\r\n}\r\n\r\nexport type State = {\r\n    puzzles: BoardMetaData[],\r\n    userData: UserData\r\n    game: {\r\n        initialBoard: Board\r\n        board: Board\r\n        boardMetaData: BoardMetaData\r\n        boardStack: Board[]\r\n        solver: {\r\n            boardBeforeSolve: Board\r\n            solveResult: SolveResult | null\r\n        } | null\r\n    } | null\r\n    inputMode: InputMode\r\n    selectedCells: Point[]\r\n    selectedDigit: number | null\r\n}\r\n\r\nconst initialState: State = {\r\n    puzzles: [],\r\n    userData: {\r\n        solved: [],\r\n        custom: [],\r\n        progress: {}\r\n    },\r\n    game: null,\r\n    inputMode: 'value',\r\n    selectedCells: [],\r\n    selectedDigit: null\r\n}\r\n\r\ntype SetState = Partial<State> | ((state: State) => Partial<State>)\r\ntype Action = { type: string, state: SetState }\r\n\r\nexport const reducer = (state: State = initialState, action: Action) => {\r\n    return {\r\n        ...state,\r\n        ...(typeof action.state === 'function' ? action.state(state) : action.state)\r\n    }\r\n}\r\n\r\nexport type Storage = {\r\n    store: (data: UserData) => any\r\n}\r\n\r\n/*\r\nIntercepts changes to userData and puts it in storage\r\n */\r\nexport const createStorageMiddleware = (storage: Storage) => store => {\r\n    let prevUserData = store.getState().userData\r\n    return next => action => {\r\n        next(action)\r\n        const currUserData = store.getState().userData\r\n        if (prevUserData !== currUserData) {\r\n            storage.store(currUserData)\r\n            prevUserData = currUserData\r\n        }\r\n    }\r\n}\r\n\r\nconst omit = (obj, key) => {\r\n    obj = {...obj}\r\n    delete obj[key]\r\n    return obj\r\n}\r\n\r\nexport const createActions = dispatch => {\r\n    const setState = (type: string, state: SetState) => dispatch(({ state, type }))\r\n\r\n    const setInputMode = (inputMode: InputMode) => setState('setInputMode', { inputMode })\r\n    const setPuzzles = (puzzles: BoardMetaData[]) => setState('setPuzzles', { puzzles })\r\n    const setUserData = (userData: UserData) => setState('setUserData', { userData })\r\n    const selectDigit = (digit: number) => setState('setDigit', state => {\r\n        return {\r\n            selectedDigit: state.selectedDigit === digit ? null : digit\r\n        }\r\n    })\r\n    const setSelectedCells = (selectedCells: Point[]) => setState('setSelectedCells', { selectedCells })\r\n    const addSelectedCell = (cell: Point) => setState('addSelectedCell', state => {\r\n        return {\r\n            selectedCells: uniqueBy([...state.selectedCells, cell], pointsEqual)\r\n        }\r\n    })\r\n\r\n    const startGame = (board: Board, boardMetaData: BoardMetaData) => setState('startGame', state => {\r\n        return {\r\n            game: {\r\n                initialBoard: board,\r\n                board,\r\n                boardMetaData,\r\n                boardStack: [],\r\n                solver: (state.game?.solver ?? null) !== null\r\n                    ? {\r\n                        boardBeforeSolve: prepareBoardForSolver(board),\r\n                        solveResult: null\r\n                    }\r\n                    : null\r\n            },\r\n            selectedCells: [],\r\n            selectedDigit: null\r\n        }\r\n    })\r\n\r\n    const startPuzzle = (metaData: BoardMetaData, fromProgress: boolean) => setState('selectPuzzle', state => {\r\n        const originalBoard = boardFromStr(metaData.boardData)\r\n        const progress = fromProgress ? state.userData.progress[metaData.boardData] ?? null : null\r\n        const board = progress ? progress : originalBoard\r\n\r\n        return {\r\n            game: {\r\n                initialBoard: board,\r\n                board,\r\n                boardMetaData: metaData,\r\n                boardStack: [],\r\n                solver: (state.game?.solver ?? null) !== null\r\n                    ? {\r\n                        boardBeforeSolve: prepareBoardForSolver(board),\r\n                        solveResult: null\r\n                    }\r\n                    : null\r\n            },\r\n            selectedCells: [],\r\n            selectedDigit: null\r\n        }\r\n    })\r\n\r\n    const toggleSolver = (solutionBoard: Board | null) => setState('toggleSolver', state => {\r\n        if (!state.game || !solutionBoard) return state\r\n\r\n        if (state.game.solver) {\r\n            return {\r\n                game: {\r\n                    ...state.game,\r\n                    solver: null\r\n                }\r\n            }\r\n        } else {\r\n            if (boardHasError(state.game.board, solutionBoard)) {\r\n                return state\r\n            }\r\n            return {\r\n                game: {\r\n                    ...state.game,\r\n                    solver: {\r\n                        boardBeforeSolve: prepareBoardForSolver(state.game.board),\r\n                        solveResult: null\r\n                    }\r\n                },\r\n                selectedCells: [],\r\n                selectedDigit: null\r\n            }\r\n        }\r\n    })\r\n\r\n    const setSolveResult = (solveResult: SolveResult | null, boardBeforeSolve: Board) => setState('setSolveResult', state => {\r\n        if(!state.game) return state\r\n\r\n        return {\r\n            game: {\r\n                ...state.game,\r\n                solver: {\r\n                    boardBeforeSolve,\r\n                    solveResult\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    const playFromSolver = () => setState('playFromSolver', state => {\r\n        if (!state.game || !state.game.solver) {\r\n            return state\r\n        }\r\n\r\n        return {\r\n            game: {\r\n                ...state.game,\r\n                boardStack: [state.game.board, ...state.game.boardStack],\r\n                board: state.game.solver.boardBeforeSolve,\r\n                solver: null\r\n            }\r\n        }\r\n    })\r\n\r\n    const setDigit = (digit: number, points: Point[], solutionBoard: Board | null) => setState('setDigit', state => {\r\n        if (!state.game || !solutionBoard || state.game.solver) return state\r\n\r\n        const board = applyInputValue(state.game.board, points, digit, state.inputMode)\r\n        const boardStr = boardToStr(state.game.initialBoard)\r\n\r\n        let userData = state.userData\r\n        if(boardIsComplete(board) && !boardHasError(board, solutionBoard)){\r\n            userData = {\r\n                ...userData,\r\n                solved: [boardStr, ...userData.solved],\r\n                progress: omit(userData.progress, boardStr)\r\n            }\r\n        }else{\r\n            userData = {\r\n                ...userData,\r\n                progress: {\r\n                    ...userData.progress,\r\n                    [boardStr]: board\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            userData,\r\n            game: {\r\n                ...state.game,\r\n                board,\r\n                boardStack: [state.game.board, ...state.game.boardStack]\r\n            }\r\n        }\r\n    })\r\n\r\n    const undo = () => setState('undo', state => {\r\n        if (!state.game || state.game.solver) return state\r\n        if (state.game.boardStack.length === 0) return state\r\n\r\n        return {\r\n            game: {\r\n                ...state.game,\r\n                board: state.game.boardStack[0],\r\n                boardStack: state.game.boardStack.slice(1)\r\n            }\r\n        }\r\n    })\r\n\r\n    return {\r\n        setPuzzles,\r\n        setUserData,\r\n        selectDigit,\r\n        setSelectedCells,\r\n        addSelectedCell,\r\n        startGame,\r\n        startPuzzle,\r\n        toggleSolver,\r\n        setSolveResult,\r\n        playFromSolver,\r\n        setDigit,\r\n        setInputMode,\r\n        undo\r\n    }\r\n}","import { UserData } from './state'\r\n\r\nconst deserialize = (data: any): UserData => {\r\n    if(!data.solved){\r\n        data.solved = []\r\n    }\r\n    if(!data.progress){\r\n        data.progress = {}\r\n    }\r\n    if(!data.custom){\r\n        data.custom = []\r\n    }\r\n\r\n    return data\r\n}\r\nconst serialize = (data: UserData): string => {\r\n    return JSON.stringify(data)\r\n}\r\n\r\nconst localStorageGet = () => {\r\n    try{\r\n        const data = JSON.parse(localStorage.getItem('sudoku') ?? '{}')\r\n        return deserialize(data)\r\n    }catch(err){\r\n        return deserialize({})\r\n    }\r\n}\r\n\r\nconst localStorageSet = (value: UserData) => {\r\n    try{\r\n        localStorage.setItem('sudoku', serialize(value))\r\n    }catch(err){}\r\n}\r\n\r\nexport const loadUserData = (): UserData => {\r\n    return localStorageGet()\r\n}\r\nexport const storeUserData = (data: UserData) => {\r\n    localStorageSet(data)\r\n}","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport { App } from './gui/app'\nimport CssBaseline from '@material-ui/core/CssBaseline'\nimport { ThemeProvider } from '@material-ui/core/styles'\nimport './index.css'\nimport { theme } from './theme'\nimport { Provider as ReduxProvider } from 'react-redux'\nimport { composeWithDevTools } from 'redux-devtools-extension'\nimport { applyMiddleware, createStore } from 'redux'\nimport { createActions, createStorageMiddleware, reducer } from './state'\nimport { loadUserData, storeUserData } from './storage'\nimport { BoardMetaData } from './core/utils/getBoardMetaData'\n\nconst storage = {\n    store: storeUserData\n}\n\nconst middleware = applyMiddleware(createStorageMiddleware(storage))\nconst enhancer = composeWithDevTools(middleware)\nexport const store = createStore(reducer, enhancer)\nexport const actions = createActions(store.dispatch)\n\nactions.setUserData(loadUserData())\n\nfetch(process.env.PUBLIC_URL + '/boards/boardsV6.txt')\n    .then(x => x.text())\n    .then(x => x\n        .split('\\n')\n        .filter(line => line.trim().length !== 0)\n        .map(line => JSON.parse(line) as BoardMetaData)\n    )\n    .then(puzzleData => actions.setPuzzles(puzzleData))\n\nReactDOM.render(\n  <React.StrictMode>\n      <ThemeProvider theme={theme}>\n          <CssBaseline>\n              <ReduxProvider store={store}>\n                <App />\n              </ReduxProvider>\n          </CssBaseline>\n      </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}